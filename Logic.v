(** * Логика: Логика в Coq *)

Require Export Tactics.

(** В предыдущих главах, мы видели много примеров заявлений о фактах
    (_пропозиций_) и способов предоставления свидетельств их 
    правдивости (_докозательства_).  В частности, мы много работали с
    _пропозициями равенства_ в форме [e1 = e2], импликациями
    ([P -> Q]), и пропозициями с кванторами ([forall
    x, P]).  В данной главе, мы увидем как Coq может быть использован
    для других знакомых форм логического вывода.

    Прежде чем погружаться в детали, давайте поговорим немного о
    статусе математических утверждений в Coq.  Вспомните что Coq есть 
    язык с _типами_, что означает что каждое осмысленное выражение
    имеет ассоциированный тип. Логические утверждения не являются
    исключением: любое утверждение которое мы можем попробовать 
    доказать в Coq имеет тип, а именно [Prop], тип _пропозиций_.
    Мы можем увидеть это с помощью команды [Check]: *)

Check 3 = 3.
(* ===> Prop *)

Check forall n m : nat, n + m = m + n.
(* ===> Prop *)

(** Заметьте, что все хорошо сформированные пропозиции имеют тип [Prop] в Coq,
    независимо от того правдивы они или нет. Просто _быть_ пропозицией
    это одно дело; быть _доказумым_ это нечто другое! *)

Check forall n : nat, n = 2.
(* ===> Prop *)

Check 3 = 4.
(* ===> Prop *)

(** Десйтвительно, пропозиции не только имеют просто тип:: они _объекты первого
    класса_ которыми можно манипулировать таким же образом как и другими
    сущностями мира Coq.  До сих пор, мы видели лишь первостепенную роль
    которую пропозиции играют: в декларациях [Theorem], [Lemma] и
    [Example]). *)

Theorem plus_2_2_is_4 :
  2 + 2 = 4.
Proof. reflexivity.  Qed.

(** Но пропозиции могут использованы многими другими способами. Например,
    мы можем задать имя пропозиции используя [Definition], также как
    мы задавали имена выражениям других сортов. *)

Definition plus_fact : Prop  :=  2 + 2 = 4.
Check plus_fact.
(* ===> plus_fact : Prop *)

(** Мы в дальнейшем можем использовать это имя в любой ситуации, где пропозиция
    ожидается -- например, как утверждение в декларации [Theorem]. *)

Theorem plus_fact_is_true :
  plus_fact.
Proof. reflexivity.  Qed.

(** Мы также можем записывать _параметризованные_ пропозиции -- т.е.,
    функции которые принимают аргументы некоторого типа и возвращают
    пропозицию. Например, следующая функция берерт число и возвращает
    пропозицию утверждающую что данное число равно трем: *)

Definition is_three (n : nat) : Prop :=
  n = 3.
Check is_three.
(* ===> nat -> Prop *)

(** В Coq, говорят что функции возвращающие пропозиции задают
    _свойства_ своих аргументов. Например, вот полиморфное свойство
    определяющее знакомое понятие _инъективной
    функции_. *)

Definition injective {A B} (f : A -> B) :=
  forall x y : A, f x = f y -> x = y.

Lemma succ_inj : injective S.
Proof.
  intros n m H. inversion H. reflexivity.
Qed.

(** Оператор равенства [=] который мы используем до сих пор также
    просто функция возвращающая [Prop]. Выражение [n = m] есть
    просто синтаксический сахар для [eq n m], определенный через механизм
    [Notation] в Coq. Так как [=] может быть использован с ээлементами любого типа
    он также полиморфен: *)

Check @eq.
(* ===> forall A : Type, A -> A -> Prop *)

(** (Заметьте что мы написали [@eq] вместо [eq]: Аргумент типа [A] для
    [eq] заявлен неявным, так что нам нужно выключить неявность аргументов
    чтобы увидеть полный тип  [eq].) *)

(* ################################################################# *)
(** * Логические Связки *)

(* ================================================================= *)
(** ** Конъюкция *)

(** _Конъюкция_ или _логическое и_ пропозиций [A] и [B] записывается
    [A /\ B], обозначая утверждение что оба [A] и [B] справедливы. *)

Example and_example : 3 + 4 = 7 /\ 2 * 2 = 4.

(** Чтобы доказать конъюнкцию, используется тактика [split].  Ее результат
    это генерация двух подцелей, по одной для каждой части утверждения: *)

Proof.
  split.
  - (* 3 + 4 = 7 *) reflexivity.
  - (* 2 + 2 = 4 *) reflexivity.
Qed.

(** Более обще, следующий принцип работает для любых двух пропозиций
    [A] и [B]: *)

Lemma and_intro : forall A B : Prop, A -> B -> A /\ B.
Proof.
  intros A B HA HB. split.
  - apply HA.
  - apply HB.
Qed.

(** Логическое утверждение с множественными стрелками есть просто
    теорема имеющая множество гипотез.  Здесь, [and_intro] говорит что,
    для любых пропозиций [A] и [B], если мы предположим что [A] правдиво
    и предположим что [B] справедливо, то [A /\ B] также справедливо.

    Так как применение теоремы с гипотезами к некоторой цели генерирует
    столько подцелей сколько гипотез она имеет, мы можем, применяя
    [and_intro] достичь тех же целей что и [split]. *)

Example and_example' : 3 + 4 = 7 /\ 2 * 2 = 4.
Proof.
  apply and_intro.
  - (* 3 + 4 = 7 *) reflexivity.
  - (* 2 + 2 = 4 *) reflexivity.
Qed.

(** **** Упражнение: 2 звездочки (and_exercise)  *)
Example and_exercise :
  forall n m : nat, n + m = 0 -> n = 0 /\ m = 0.
Proof.
  (* ЗАПОЛНИТЬ ЗДЕСЬ *) Admitted.
(** [] *)

(** Столько о доказательстве утверждений с конъюкцией. Для движения
    в другом направлении -- т.е., при _использовании_ конъюктивной 
    гипотезы для доказательства чего либо иного -- мы используем
    тактику [destruct].

    Если контекст доказательства содержит гипотезу [H] формы [A /\
    B], запись [destruct H as [HA HB]] уберет [H] из контекста
    и добавит две новые гипотезы: [HA], утверждающую что [A] 
    справедливо, и [HB], утверждающую что [B] справедливо. Например: *)

Lemma and_example2 :
  forall n m : nat, n = 0 /\ m = 0 -> n + m = 0.
Proof.
  intros n m H.
  destruct H as [Hn Hm].
  rewrite Hn. rewrite Hm.
  reflexivity.
Qed.

(** Как обычно, мы также можем разбить [H] когда мы ее вводим вместо введения
    и последующего разбивания: *)

Lemma and_example2' :
  forall n m : nat, n = 0 /\ m = 0 -> n + m = 0.
Proof.
  intros n m [Hn Hm].
  rewrite Hn. rewrite Hm.
  reflexivity.
Qed.

(** вы можете задать вопрос, почему мы вообще упаковали две гипотезы [n = 0]
    и [m = 0] в единную конъюкцию, так как мы также могли выразить эту
    теорему с двумя отдельными предпосылками: *)

Lemma and_example2'' :
  forall n m : nat, n = 0 -> m = 0 -> n + m = 0.
Proof.
  intros n m Hn Hm.
  rewrite Hn. rewrite Hm.
  reflexivity.
Qed.

(** В данном случае, нет особой разницы между этими двумя теоремами.
    Но часто нужно явно разобрать конъюкции которые возникают
    из промежуточных шагов в доказательствах, особенно в крупных
    проектах. Вот упрощенный пример: *)

Lemma and_example3 :
  forall n m : nat, n + m = 0 -> n * m = 0.
Proof.
  intros n m H.
  assert (H' : n = 0 /\ m = 0).
  { apply and_exercise. apply H. }
  destruct H' as [Hn Hm].
  rewrite Hn. reflexivity.
Qed.

(** Другая частая ситуация с конъюкцией заключается в том, что мы
    знаем [A /\ B] но в некотором контексте нам нужно лишь [A] (или просто [B]).
    Следующие леммы полезны в таких случаях: *)

Lemma proj1 : forall P Q : Prop,
  P /\ Q -> P.
Proof.
  intros P Q [HP HQ].
  apply HP.  Qed.

(** **** Упражнение: 1 звездочка, дополнительное (proj2)  *)
Lemma proj2 : forall P Q : Prop,
  P /\ Q -> Q.
Proof.
  (* ЗАПОЛНИТЬ ЗДЕСЬ *) Admitted.
(** [] *)

(** Наконец, нам иногда нужно перегрупировать порядок в конъюнкции
    и/или сгруппировать конъюкции в более крупные коньюкции.  Следующие
    теоремы коммутативности и ассоциативности удобны в таких случаях. *)

Theorem and_commut : forall P Q : Prop,
  P /\ Q -> Q /\ P.
Proof.
  (* ПРОРАБОТАНО В КЛАССЕ *)
  intros P Q [HP HQ].
  split.
    - (* left *) apply HQ.
    - (* right *) apply HP.  Qed.
  
(** **** Упражнение: 2 звездочки (and_assoc)  *)
(** (В следующем доказательстве ассоциативности, заметьте как _вложенный_
    шаблон intro разбивает гипотезу [H : P /\ (Q /\ R)] до 
    [HP : P], [HQ : Q], и [HR : R].  Завершите доказательство
    оттуда.) *)

Theorem and_assoc : forall P Q R : Prop,
  P /\ (Q /\ R) -> (P /\ Q) /\ R.
Proof.
  intros P Q R [HP [HQ HR]].
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** Кстати, инфиксная нотация [/\] есть на самом деле синтаксический сахар
    для [and A B].  Т.е., [and] является оператором Coq который берет две
    пропозиции в качестве аргументов и выдает пропозицию. *)

Check and.
(* ===> and : Prop -> Prop -> Prop *)

(* ================================================================= *)
(** ** Дизнъюнкция *)

(** Другая важная связка _дизъюнкция_, или _логическое или_
    двух пропозиций: [A \/ B] справедливо если хотябы [A] или [B]
    справедливы.  (Альтернативно, мы можем написать [or A B], где [or : Prop ->
    Prop -> Prop].)

    Для использования гипотезы с дизъюнкцией в доказательстве, мы
    используем разбор случаев, который, как для [nat] или других типов данных,
    может быть сделан с [destruct] или [intros].  Приведем пример: *)

Lemma or_example :
  forall n m : nat, n = 0 \/ m = 0 -> n * m = 0.
Proof.
  (* Данный шаблон неявно производит анализ случаев на
     [n = 0 \/ m = 0] *)
  intros n m [Hn | Hm].
  - (* Здесь, [n = 0] *)
    rewrite Hn. reflexivity.
  - (* Здесь, [m = 0] *)
    rewrite Hm. rewrite <- mult_n_O.
    reflexivity.
Qed.

(** Мы можем увидеть в данном примере, что когда мы производим
    разбор случаев на дизнъюнкции [A \/ B], мы должны удовлетворить двух 
    требованиям доказательства, каждая показывает что заключение
    справедливо при разном предположении -- [A] для первой подцели и
    [B] для второй. Заметьте что шаблон разбора случаев ([Hn | Hm]) 
    позволяет нам назвать гипотезы сгенерированные для каждой подцели.

    Обратно, чтобы показать что дизньюнкция справедлива, нам надо
    показать, что одна из ее сторон справедлива. Это делается
    с помощью двух тактик, [left] (лево) и [right] (право).  Как их
    имена говорят, первая требует доказать левую сторону дизнъюкции,
    вотая требует доказательства правой части. Вот тривиальный пример... *)

Lemma or_intro : forall A B : Prop, A -> A \/ B.
Proof.
  intros A B HA.
  left.
  apply HA.
Qed.

(** ... и слегка более интересный пример требующий использования как
    [left] так и [right]: *)

Lemma zero_or_succ :
  forall n : nat, n = 0 \/ n = S (pred n).
Proof.
  intros [|n].
  - left. reflexivity.
  - right. reflexivity.
Qed.

(** **** Упражнение: 1 звездочка (mult_eq_0)  *)
Lemma mult_eq_0 :
  forall n m, n * m = 0 -> n = 0 \/ m = 0.
Proof.
  (* ЗАПОЛНИТЬ ЗДЕСЬ *) Admitted.
(** [] *)

(** **** Упражнение: 1 звездочка (or_commut)  *)
Theorem or_commut : forall P Q : Prop,
  P \/ Q  -> Q \/ P.
Proof.
  (* ЗАПОЛНИТЬ ЗДЕСЬ *) Admitted. 
(** [] *)

(* ================================================================= *)
(** ** Ложь и Отрицание *)

(** До сих пор, мы были в основном заинтересованы доказательством
    того что какие то вещи _справедливы_ -- сумма коммутативна,
    конкатенация списков ассоциативно и т.д. Конечно, мы также
    можем быть заинтересованы в _отрицательных_ результатах,
    показывающих, что некоторые пропозиции _не_ справедливы.
    В Coq, такие отрицательные утверждения выражены с помощью оператора
    отрицания [~].

    Чтобы увидеть как отрицание работает, вспомним дискуссию о _принципе
    взрыва_ из главы [Tactics]; он утверждает что, если мы примем
    противоречие, тогда любая пропозиция может быть выведена.
    Следуя данной интуиции, мы можем определить [~ P] ("не [P]") ка
    [forall Q, P -> Q].  Coq делает слегка иной выбор, определяя
    [~ P] как [P -> False], где [False] есть _определенная_ противоречивая 
    пропозиция определенная в стандартной библиотеке. *)

Module MyNot.

Definition not (P:Prop) := P -> False.

Notation "~ x" := (not x) : type_scope.

Check not.
(* ===> Prop -> Prop *)

End MyNot.

(** Так как [False] есть противоречивая пропозиция, принцип взрыва также применим к ней,
    Если мы получим [False] в наш контекст доказательства, мы можем
    применить [destruct] к нему и завершить любую цель: *)

Theorem ex_falso_quodlibet : forall (P:Prop),
  False -> P.
Proof.
  (* ПРОРАБОТАНО В КЛАССЕ *)
  intros P contra.
  destruct contra.  Qed.

(** Латинское _ex falso quodlibet_ означает, буквально, "из лжи следует
    все что угодно"; это другое частое имя для принципа взрыва. *)

(** **** Упражнение: 2 звездочки, дополнительное (not_implies_our_not)  *)
(** Показать что определение Coq для отрицания приводит к интуитивному, что
    упомянуто ранее: *)

Fact not_implies_our_not : forall (P:Prop),
  ~ P -> (forall (Q:Prop), P -> Q).
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** Вот как мы используем [not] чтобы сказать что [0] и [1] 
    разные элементы [nat]: *)

Theorem zero_not_one : ~(0 = 1).
Proof.
  intros contra. inversion contra.
Qed.

(** Такие утверждения неравеснтва достаточно часты чтобы
    требовать специальной нотации, [x <> y]: *)

Check (0 <> 1).
(* ===> Prop *)

Theorem zero_not_one' : 0 <> 1.
Proof.
  intros H. inversion H.
Qed.

(** Требуется небольшой практики для того чтобы научиться работать
    с отрицанием в Coq. Хотя вы можете ясно видеть, что утверждение
    включающее отрицании верно, может быть слегка непросто вначале
    привести все в нужную конфигурацию, чтобы Coq понял! вот доказательства
    некоторых знакомых фактов для разогрева. *)

Theorem not_False :
  ~ False.
Proof.
  unfold not. intros H. destruct H. Qed.

Theorem contradiction_implies_anything : forall P Q : Prop,
  (P /\ ~P) -> Q.
Proof.
  (* ПРОРАБОТАНО В КЛАССЕ *)
  intros P Q [HP HNA]. unfold not in HNA.
  apply HNA in HP. destruct HP.  Qed.

Theorem double_neg : forall P : Prop,
  P -> ~~P.
Proof.
  (* ПРОРАБОТАНО В КЛАССЕ *)
  intros P H. unfold not. intros G. apply G. apply H.  Qed.

(** **** Упражнение: 2 звездочки, продвинутое, рекомендованное (double_neg_inf)  *)
(** Запишите неформальное доказательство [double_neg]:

   _Теорема_: Из [P] следует [~~P], для любой пропозиции [P].

   _Доказательство_:
(* ЗАПОЛНИТЬ ЗДЕСЬ *)
   []
*)

(** **** Упражнение: 2 звездочки, рекомендовано (contrapositive)  *)
Theorem contrapositive : forall P Q : Prop,
  (P -> Q) -> (~Q -> ~P).
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** **** Упражнение: 1 звездочка (not_both_true_and_false)  *)
Theorem not_both_true_and_false : forall P : Prop,
  ~ (P /\ ~P).
Proof.
  (* ЗАПОЛНИТЬ ЗДЕСЬ *) Admitted.
(** [] *)

(** **** Упражнение: 1 звездочка, продвинутое (informal_not_PNP)  *)
(** Запишите неформальное доказательство (по русски) пропозиции [forall P
    : Prop, ~(P /\ ~P)]. *)

(* ЗАПОЛНИТЕ ЗДЕСЬ *)
(** [] *)

(** Аналогично, так как неравенство включающее отрицание, оно требует
    небольшой практики для того чтобы работать легко. Вот один полезный
    прием. Если вы пытаетесь доказать цель, которая бесмысслена
    (т.е., состояние цели есть [false = true]), применяйте 
    [ex_falso_quodlibet] для того чтобы сменить цель на [False]. Это
    делает более легким применение предположений в форме [~P] которые
    могут быть доступны в контексте -- в частности, предположения в форме
    [x<>y]. *)

Theorem not_true_is_false : forall b : bool,
  b <> true -> b = false.
Proof.
  intros [] H.
  - (* b = true *)
    unfold not in H.
    apply ex_falso_quodlibet.
    apply H. reflexivity.
  - (* b = false *)
    reflexivity.
Qed.

(** Так как рассужение с помощью [ex_falso_quodlibet] довольно часто, Coq
    предоставляет встроенную тактику, [exfalso], для ее применения. *)

Theorem not_true_is_false' : forall b : bool,
  b <> true -> b = false.
Proof.
  intros [] H.
  - (* b = false *)
    unfold not in H.
    exfalso.                (* <=== *)
    apply H. reflexivity.
  - (* b = true *) reflexivity.
Qed.

(* ================================================================= *)
(** ** Правда *)

(** Кроме [False], стандартная библиотека Coq также определяет [True] (Правда),
    пропозиция которая тривиально справедлива. Чтобы доказать ее, мы используем
    заранее определенную константу [I : True]: *)

Lemma True_is_true : True.
Proof. apply I. Qed.

(** В отличие от [False], которая используется часто, [True] используется
    достаточно редко, так как она тривиальна (и поэтому не интересна) для
    доказательства как цель, и не несет какой либо полезной информации
    в качестве гипотезы. Но она может быть довольно полезна при определении
    сложных [Prop]ов использующих условия или как параметр для [Prop]ов высшего
    порядка. Мы увидем некоторые примеры такого использования [True] в дальнейшем. *)

(* ================================================================= *)
(** ** Логическая Эквивалентность *)

(** Удобная "тогда и только тогда" связка, которая утверждает что
    две пропозиции имеют одинаковую правдивость, есть просто конъюкция
    двух импликаций. *)

Module MyIff.

Definition iff (P Q : Prop) := (P -> Q) /\ (Q -> P).

Notation "P <-> Q" := (iff P Q)
                      (at level 95, no associativity)
                      : type_scope.

End MyIff.

Theorem iff_sym : forall P Q : Prop,
  (P <-> Q) -> (Q <-> P).
Proof.
  (* ПРОРАБОТАНО В КЛАССЕ *)
  intros P Q [HAB HBA].
  split.
  - (* -> *) apply HBA.
  - (* <- *) apply HAB.  Qed.

Lemma not_true_iff_false : forall b,
  b <> true <-> b = false.
Proof.
  (* ПРОРАБОТАНО В КЛАССЕ *)
  intros b. split.
  - (* -> *) apply not_true_is_false.
  - (* <- *)
    intros H. rewrite H. intros H'. inversion H'.
Qed.

(** **** Упражнение: 1 звездочка, дополнительное (iff_properties)  *)
(** Используя предыдущее доказательство того что [<->] симметрично ([iff_sym]) в
    качестве руководства, докажите что оно также рефлексивно и транзитивно. *)

Theorem iff_refl : forall P : Prop,
  P <-> P.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Theorem iff_trans : forall P Q R : Prop,
  (P <-> Q) -> (Q <-> R) -> (P <-> R).
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** **** Упражнение: 3 звездочки (or_distributes_over_and)  *)
Theorem or_distributes_over_and : forall P Q R : Prop,
  P \/ (Q /\ R) <-> (P \/ Q) /\ (P \/ R).
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] **)

(** Некоторые из тактик Coq обрабатывают [iff] утверждения особо, избегая
    необходимости для некоторых манипуляций низкого уровня. В частности,
    [rewrite] и [reflexivity] могут быть использованы с утверждениями [iff]
    а не только с равенствами. Чтобы включить это специальное поведение
    нам надо импортировать специальную библиотеку Coq, которая позовляет
    переписывание с другими формулами кроме равенства: *)

Require Import Coq.Setoids.Setoid.

(** Вот простой пример демонстрирующий как эти тактики работают с
    [iff].  Во первых, давайте докажем пару простых эквивалентностей iff: *)

Lemma mult_0 : forall n m, n * m = 0 <-> n = 0 \/ m = 0.
Proof.
  split.
  - apply mult_eq_0.
  - apply or_example.
Qed.

Lemma or_assoc :
  forall P Q R : Prop, P \/ (Q \/ R) <-> (P \/ Q) \/ R.
Proof.
  intros P Q R. split.
  - intros [H | [H | H]].
    + left. left. apply H.
    + left. right. apply H.
    + right. apply H.
  - intros [[H | H] | H].
    + left. apply H.
    + right. left. apply H.
    + right. right. apply H.
      
Qed.

(** Мы теперь можем использовать данные факты с [rewrite] и [reflexivity] для
    получения удобного доказательства утверждений включающих эквивалентности.
    Вот другая версия предыдущего результата [mult_0]: *)

Lemma mult_0_3 :
  forall n m p, n * m * p = 0 <-> n = 0 \/ m = 0 \/ p = 0.
Proof.
  intros n m p.
  rewrite mult_0. rewrite mult_0. rewrite or_assoc.
  reflexivity.
Qed.

(** Тактика [apply] также может быть использована с [<->]. Когда мы
    предоставляем эквивалентность как ее аргумент, [apply] пытается угадать
    какую сторону эквивалентности использовать. *)

Lemma apply_iff_example :
  forall n m : nat, n * m = 0 -> n = 0 \/ m = 0.
Proof.
  intros n m H. apply mult_0. apply H.
Qed.

(* ================================================================= *)
(** ** Квантор Существования *)

(** Другая важная логическая связка это  _квантор существования_.
    Сказать что существует некоторое [x] типа [T] такое что
    некоторое свойство [P] справедливо от [x], мы пишем [exists x : T,
    P]. Как и с [forall], аннотация типа [: T] может быть опущена если
    Coq может сам вывести из контекста какой тип должен быть у [x].

    Для доказательства утверждения в форме [exists x, P], мы должны показать
    что [P] имеет место для некоторого специального выбора значения [x],
    известного как _свидетель (witness)_ существования. Это делается в два шага: 
    во первых, мы явно говорим Coq какого свидетеля [t] мы задумали, используя
    тактику [exists t]; затем мы дказываем что [P] имеет место после того
    как все появления [x] заменены на [t]. Вот пример: *)

Lemma four_is_even : exists n : nat, 4 = n + n.
Proof.
  exists 2. reflexivity.
Qed.

(** Обратно, если у нас есть экзистенциальная гипотеза [exists x, P] в
    контексте, мы можем разложить ее для получения свидетеля [x] и гипотезы
    утверждающей что [P] справедлива от [x]. *)

Theorem exists_example_2 : forall n,
  (exists m, n = 4 + m) ->
  (exists o, n = 2 + o).
Proof.
  intros n [m Hm].
  exists (2 + m).
  apply Hm.  Qed.

(** **** Упражнение: 1 звездочка (dist_not_exists)  *)
(** Докажите что "[P] справедливо для любых [x]" означает что "нет такого [x] для
    которого [P] не имеет места." *)

Theorem dist_not_exists : forall (X:Type) (P : X -> Prop),
  (forall x, P x) -> ~ (exists x, ~ P x).
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** **** Упражнение: 2 звездочки (dist_exists_or)  *)
(** Докажите что экзистенциальная квантификация дистрибутивна по
    дизъюнкции. *)

Theorem dist_exists_or : forall (X:Type) (P Q : X -> Prop),
  (exists x, P x \/ Q x) <-> (exists x, P x) \/ (exists x, Q x).
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted. 
(** [] *)

(* ################################################################# *)
(** * Программирование с Пропозициями *)

(** Логические связки которые мы увидели предоставляют богатый
    словарь для определения сложных пропозиций из более простых.
    Для иллюстрации, рассмотрим как выразить утвержения что
    элемент [x] встречается в списке [l].  Заметьте, что данное 
    свойство имеет простую реккурсивную структуру:

    - Если [l] пустой список, тогда [x] не может появиться в нем,
      так что свойство "[x] встречается в [l]" попросту ложно.

    - Иначе, [l] имеет форму [x' :: l'].  В этом случае, [x]
      появляется в [l] если либо он равен [x'] или появляется в
      [l']. *)

(** Мы можем перевести это напрямую в функцию Coq, [In].
    (Она также может бытъ в стандарной библиотеке Coq.) *)

Fixpoint In {A : Type} (x : A) (l : list A) : Prop :=
  match l with
  | [] => False
  | x' :: l' => x' = x \/ In x l'
  end.

(** Когда [In] применен к конкретному списку, она раскрывается
    в конкретную последовательность вложенных конъюнкций. *)

Example In_example_1 : In 4 [3; 4; 5].
Proof.
  simpl. right. left. reflexivity.
Qed.

Example In_example_2 :
  forall n, In n [2; 4] ->
  exists n', n = 2 * n'.
Proof.
  simpl.
  intros n [H | [H | []]].
  - exists 1. rewrite <- H. reflexivity.
  - exists 2. rewrite <- H. reflexivity.
Qed.

(** (Заметьте как мы использовали пустой шаблон, чтобы разобраться с последним случаем
    _en passant_.) *)

(** Мы также можем доказать более общие, высокого порядка леммы об [In].
    Заметьте, в следующем, как [In] начинается с применения к переменной и
    раскрывается только когда мы делаем разбор случаев для данной переменной: *)

Lemma In_map :
  forall (A B : Type) (f : A -> B) (l : list A) (x : A),
    In x l ->
    In (f x) (map f l).
Proof.
  intros A B f l x.
  induction l as [|x' l' IHl'].
  - (* l = nil, contradiction *)
    simpl. intros [].
  - (* l = x' :: l' *)
    simpl. intros [H | H].
    + rewrite H. left. reflexivity.
    + right. apply IHl'. apply H.
Qed.

(** Данный способ определения пропозиций, хотя и удобный в некоторых
    случаях, также имеет свои недостатки. В частности, он следует
    стандартным ограничениям Coq для определения рекурсивных функций
    т.е. условию того, что они должны быть "очевидно завершающимися."
    В следующей части мы увидем как определить пропозиции _индуктивно_, 
    другой техникой имеющей свои собственные сильные и слабые стороны. *)


(** **** Упражнение: 2 звездочки (In_map_iff)  *)
Lemma In_map_iff :
  forall (A B : Type) (f : A -> B) (l : list A) (y : B),
    In y (map f l) <->
    exists x, f x = y /\ In x l.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.   
 (** [] *)

(** **** Упражнение: 2 звездочки (in_app_iff)  *)
Lemma in_app_iff : forall A l l' (a:A),
  In a (l++l') <-> In a l \/ In a l'.
Proof.
  (* ЗАПОЛНИТЬ ЗДЕСЬ *) Admitted. 
(** [] *)

(** **** Упражнение: 3 звездочки (All)  *)
(** Вспомните что функции возвращающие пропозиции могут быть
    рассмотрены как _свойства_ своих аргументов. Например, если [P]
    имеет тип [nat -> Prop], то [P n] утверждает что свойство [P] 
    справедливо для [n].

    Вдохновляясь [In], напишите рекурсивную функцию [All]
    утверждающую что тоже самое свойство [P] имеет место для всех элементов списка
    [l]. Чтобы убедиться, что ваше определенние корректно, докажите лемму [All_In]
    внизу.  (Безусловно, ваше определение _не_ должно просто переформулировать
    левую сторону [All_In].) *)

Fixpoint All {T} (P : T -> Prop) (l : list T) : Prop 
(* ЗАМЕНИТЕ ЭТУ СТРОКУ  := _ваше определение_ . *). Admitted.
     
Lemma All_In :
  forall T (P : T -> Prop) (l : list T),
    (forall x, In x l -> P x) <->
    All P l.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** **** Упражнение: 3 звездочки (combine_odd_even)  *)
(** Завершите определение функции [combine_odd_even]. Она берет
    в качестве аргументов два свойства чисел, [Podd] и
    [Peven], и должно возвращать свойство [P] такое что [P n] эквивалентно
    [Podd n] когда [n] нечетно и эквивалентно [Peven n]
    в обратном случае. *)

Definition combine_odd_even (Podd Peven : nat -> Prop) : nat -> Prop 
  (* ЗАМЕНИТЕ ЭТУ ЛИНИЮ  := _ваше определение_ . .*). Admitted.

  
(** Чтобы протестировать ваше определение, докажите следующий факт: *)

Theorem combine_odd_even_intro :
  forall (Podd Peven : nat -> Prop) (n : nat),
    (oddb n = true -> Podd n) ->
    (oddb n = false -> Peven n) ->
    combine_odd_even Podd Peven n.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted. 
    
Theorem combine_odd_even_elim_odd :
  forall (Podd Peven : nat -> Prop) (n : nat),
    combine_odd_even Podd Peven n ->
    oddb n = true ->
    Podd n.
Proof.
  (*  ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.


Theorem combine_odd_even_elim_even :
  forall (Podd Peven : nat -> Prop) (n : nat),
    combine_odd_even Podd Peven n ->
    oddb n = false ->
    Peven n.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(* ################################################################# *)
(** * Применение Теорем к Аргументам *)

(** Одно свойство Coq которое отличает его от многих других помощников
    в доказательствах состоит в том, что он рассматривает
    _доказательства_ как объекты первого класса.

    Есть много чего можно об этом рассказать, но нет необходимости
    понимать все в деталях для того чтобы использовать Coq. Данная
    секция лишь знакомит, в то время как более глубокое изложение
    может быть найдено в дополнительных главах [ProofObjects] и
    [IndPrinciples]. *)

(** Мы уже видели как использовать команду [Check] чтобы Coq 
    напечатал тип выражения. Мы также можем использовать [Check]
    чтобы узнать к какой теореме конкретный идентификатор
    аппелирует. *)

Check plus_comm.
(* ===> forall n m : nat, n + m = m + n *)

(** Coq печатает _утверждение_ теоремы [plus_comm] таким же образом
    как он печатает _тип_ любого терма если мы используем [Check]. Почему?

    Причина в том, что идентификатор [plus_comm] на самом деле относится к
    _объекту доказательства_ -- структуре данных, которая представляет
    логический вывод устанавливающий правдивость утверждения [forall n m
    : nat, n + m = m + n].  Тип данного объекта _есть_ утверждение
    данной теоремы, доказательством которой объект является.

    Интуитивно, это имеет смысл, так как утверждение теоремы говорит
    нам для чего мы можем использовать теорему, также как и тип
    вычислительного объекта говорит нам что мы можем сделать с
    объектом этого типа -- т.е. если мы имеем терм типа [nat -> nat -> nat],
    мы можем предоставить ему два [nat] как аргументы и получить [nat]
    обратно.  Аналогично, если у нас есть объект типа [n = m -> n + n = m + m]
    и мы предоставляем ему "аргумент" типа [n = m], мы можем 
    вывести [n + n = m + m].

    Технически, данная аналогия идет еще дальше: применяя теорему
    как если бы она была бы функция, к гипотезе с соответствующими
    типами, мы можем специализировать ее результат, без того чтобы
    прибегать к промежуточным утверждениям. Например, мы хотели бы 
    доказать следующий результат: *)

Lemma plus_comm3 :
  forall n m p, n + (m + p) = (p + m) + n.

(** На первый взгляд кажется, что мы могли бы доказать эту теорему
    двумя переписываниеми [plus_comm] так чтобы сделать обе стороны
    одинаковыми. Проблема здесь в том, что второй [rewrite] просто
    отменит результат первого. *)

Proof.
  intros n m p.
  rewrite plus_comm.
  rewrite plus_comm.
  (* Мы так где начинали... *)

(** Один простой способ устранения этой проблемы, в использовании
    только инструментов которыми мы уже владеем, использовать [assert]
    чтобы вывести специализированную версию [plus_comm] которая может
    быть использована для переписывания точно той части, что нам нуюна. *)

  rewrite plus_comm.
  assert (H : m + p = p + m).
  { rewrite plus_comm. reflexivity. }
  rewrite H.
  reflexivity.
Qed.

(** Более элегантная альтернатива состоит в применении [plus_comm] напрямую
    к аргументам мы хотим инстанционировать с ней, также как мы применяем
    полиморфную функцию к аргументу типа. *)

Lemma plus_comm3_take2 :
  forall n m p, n + (m + p) = (p + m) + n.
Proof.
  intros n m p.
  rewrite plus_comm.
  rewrite (plus_comm m).
  reflexivity.
Qed.

(** Вы можете использовать "теоремы как функции" таким способом с практичски
    любыми тактиками которые принимают имя теоремы как аргумент. Заметьте,
    также что применение теоремы использует тот же механизм вывода, что и
    применение функции; таким образом, возможно, например, предоставить
    пустые шаблоны как аргументы что будут автоматически выведены, или
    задекларировать какие некоторые гипотезы для теоремы неявно по умолчанию.
    Данные возможности проиллюстрированы в следующем доказательстве. *)

Example lemma_application_ex :
  forall {n : nat} {ns : list nat},
    In n (map (fun m => m * 0) ns) ->
    n = 0.
Proof.
  intros n ns H.
  destruct (proj1 _ _ (In_map_iff _ _ _ _ _) H)
           as [m [Hm _]].
  rewrite mult_0_r in Hm. rewrite <- Hm. reflexivity.
Qed.

(** Мы увидем больше примеров идиом из данной секции в последующих
    главах. *)

(* ################################################################# *)
(** * Coq и Теория Множеств *)

(** Логическое ядро Coq, Исчисление Индуктивных Конструкций 
    (_Calculus of Inductive Constructions_), имеет важные отличия
    от других формальных систем, используемых математиками для точного
    строгого написания доказательств. Например, в наиболее популярной
    основе для мейнстримовой математики на бумаге, Теории Множеств
    Цермело Френкеля (ZFC), математический объект может потенциально быть
    элементом многих различных множеств; а терм в логикеэ Coq, с другой
    стороны, есть элемент максимум одного типа. Данная разница часто
    приводит к слегка разным путям записи неформальных математических
    концепций, тем не менне они вполне естественны и легки для работы.
    Например, вместо утверждения того что натуральное число
    [n] принадлежит множеству четных чисел, мы скажем в Coq что
    [ev n] справедливо, где [ev : nat -> Prop] есть свойство 
    описывающее четные числа.

    Тем не менее, есть некоторые случаи, для которых перевод стандартных
    математических рассуждений в Coq может быть либо неудобным или иногда
    даже невозможным, если только не обогатить базовую логику дополнительными
    аксиомами. Мы завершаем данную главу короткой дискуссией некоторых из самых
    значительных различий этих двух миров. *)

(** ** Функциональная Расширяемость

    Утверждение равенства которое мы видели до сих пор в основном 
    затрагивало элементы индуктивных типов ([nat], [bool], etc.). Но
    Так как оператор равенства в Coq полиморфен, жто не единственные
    возможности -- в частности, мы можем записать пропозиции
    утверждающие, что две _функции_ равны друг другу: *)

Example function_equality_ex : plus 3 = plus (pred 4).
Proof. reflexivity. Qed.

(** В математической практике, две функции [f] и [g] 
    считаются равными если они производят тот же результат:

    (forall x, f x = g x) -> f = g

    Это известно как принцип _функциональной расширяемости_.

    Неформально, "свойство расширяемости" это то которое
    связано с видимым поведением объекта. Таким образом,
    функциональная расширяемость просто означает, что идентичность
    функции полностью определена тем что мы можем в ее случае 
    пронаблюдать -- т.е., на языке термов Coq, результатами которые
    получаются при ее применении.

    Функциональная расширяемость не является частью базовых аксиом Coq:
    единственный способ показать что две функции равны состоит
    в упрощении (как мы это сделали в доказательстве [function_equality_ex]).
    Но мы можем добавить ее в базовую логику Coq используя команду [Axiom]
    command. *)

Axiom functional_extensionality : forall {X Y: Type}
                                    {f g : X -> Y},
  (forall (x:X), f x = g x) -> f = g.

(** Использование [Axiom] имеет тот же эффект, что и утверюдение теоремы
    и пропуск доказательства с использованием [Admitted], но она также 
    предупреждает пользователя о том, что это не что то к чему мы возвратимся
    и заполним позжеэ!

    Мы можем вызвать функциональную расширяемость в доказательствах: *)

Lemma plus_comm_ext : plus = fun n m => m + n.
Proof.
  apply functional_extensionality. intros n.
  apply functional_extensionality. intros m.
  apply plus_comm.
Qed.

(** Естественно, мы должны быть осторожны, когда добавляем  новые
    аксиомы в логику Coq, так как они могут сделать вывод противоречивым
    -- т.е., станет возможно доказать любую пропозицию, включая [False]!
    К сожалению, нет простого способа сказать когда аксиома безопасна:
    установление непротиворечивости какой либо комбинации аксиом есть
    сложная работа. К счастью, известно, что добавление функциональной
    расширяемости, в частности, непротиворечиво.

    Заметьте, что возможно проверить когда конкретное доказательство
    основывается на дополнительных аксиомах, используя команду
    [Print Assumptions]. Например, если мы запустим ее на [plus_comm_ext],
    мы видем что она использует [functional_extensionality]: *)

Print Assumptions plus_comm_ext.
(* ===>
     Axioms:
     functional_extensionality :
         forall (X Y : Type) (f g : X -> Y),
                (forall x : X, f x = g x) -> f = g *)

(** **** Упражнение: 5 звездочек (tr_rev)  *)
(** Одна проблема с определением функции разворачивающей список
    [rev] состоит в том, что она вызывает [app] на каждом шагу;
    запуск [app] требует времени асимптотически линейного от
    размера списка, что значит [rev] имеет квадратичную скорость.
    Мы можем улучшить это с помощью следующего определения: *)

Fixpoint rev_append {X} (l1 l2 : list X) : list X :=
  match l1 with
  | [] => l2
  | x :: l1' => rev_append l1' (x :: l2)
  end.

Definition tr_rev {X} (l : list X) : list X :=
  rev_append l [].

(** Данная версия использует _хвостовую рекурсию_, так как рекурсивный
    вызов функции есть последняя операция которую надо сделать (т.е.,
    нам нет нужды запускать [++] после реккурсивного вызова); хороший
    компилятор произведет очень эффективный код для данного случая.
    Докажите, что оба определения действительно эквиваленты. *)


Lemma tr_rev_correct : forall X, @tr_rev X = @rev X.
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(* ================================================================= *)
(** ** Пропозиции и Булевы Значения *)

(** Мы увидели что Coq имеет два разных способа записать логические
    факты: с _булевыми значениями_ (типа [bool]), а также
    _пропоициями_ (типа [Prop]). Например, для утверждения того что
    число [n] четно, мы можем сказать либо (1) что [evenb n] возвращает
    [true] или (2) есть некоторое [k] такое что [n = double k].
    Действительно, данные два понятия четности эквивалентны, как это легко
    может быть показано с помощью пары вспомогательных лемм ( одна
    из которых оставлена как упражнение).

    Мы часто говорим, что булево [evenb n] _отражает_ пропозицию
    [exists k, n = double k].  *)

Theorem evenb_double : forall k, evenb (double k) = true.
Proof.
  intros k. induction k as [|k' IHk'].
  - reflexivity.
  - simpl. apply IHk'.
Qed.

(** **** Упражнение: 3 звездочки (evenb_double_conv)  *)
Theorem evenb_double_conv : forall n,
  exists k, n = if evenb n then double k
                else S (double k).
Proof.
  (* Подсказка: Используйте лемму [evenb_S] из [Induction.v]. *)
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

Theorem even_bool_prop : forall n,
  evenb n = true <-> exists k, n = double k.
Proof.
  intros n. split.
  - intros H. destruct (evenb_double_conv n) as [k Hk].
    rewrite Hk. rewrite H. exists k. reflexivity.
  - intros [k Hk]. rewrite Hk. apply evenb_double.
Qed.

(** Аналогично, для того чтобы утверждать что два числа [n] и [m] равны, мы
    можем сказать либо (1) что [beq_nat n m] возвращает [true] или (2) что [n =
    m].  Эти два понятия эквивалентны. *)

Theorem beq_nat_true_iff : forall n1 n2 : nat,
  beq_nat n1 n2 = true <-> n1 = n2.
Proof.
  intros n1 n2. split.
  - apply beq_nat_true.
  - intros H. rewrite H. rewrite <- beq_nat_refl. reflexivity.
Qed.

(** Тем не менее, в то время как булевы и пропозиционные формулировки 
    утверждения эквивалентны с точки зрения чисто логической точки
    зрения, мы также видели что ин нет необходимости быть эквивалентными
    _операционально_. Равенство предоставляет нам экстремальный пример:
    знание того что [beq_nat n m = true] обычно мало помагает в середине
    доказательства включающих [n] и [m]; тем не менее, если мы сконвертируем
    это утверждение в эквивалентную форму [n = m], мы сможем использовать
    переписывание.

    Случай четных чисел также интересен. Вспомните что, когда мы
    доказываем в обратном направлении [even_bool_prop] ([evenb_double],
    идя от пропозиционального к булевому утверждению) мы использовали
    простую индукцию по [k]).  С другой стороны, обратное 
    (упражнение [evenb_double_conv]) требует умного обобщения, так как 
    мы не можем напрямую доказать [(exists k, n = double k) -> evenb n = true].

    Для данных примеров, пропозициональные утверждения были более
    полезны по сравнению с их булевыми аналогами, но это не всегда так.
    К примеру, мы не можем тестировать является ли общая пропозиция
    справедливой или нет в функциональном определении; как следствие,
    следующий фрагмент кода отвергнут: *)

Fail Definition is_even_prime n :=
  if n = 2 then true
  else false.

(** Coq жалуется что [n = 2] имеет тип [Prop], в то время как ожидает
    элементы [bool] (или какого либо другого индуктивного типа
    с двумя элементами). Причина данного сообщения об ошибке связана с
    _вычислительной_ природой базового языка Coq, который задуман так
    что каждая функция которую он выражает вычислима и тотальна.
    Одна из причин для этого в том, что он позволает экстракцию
    работающих программ из разработок Coq. Как следствие, 
    [Prop] в Coq _не_ имеет операции для универсального анализа
    случаев говорящей является ли заданная пропозиция правдивой или нет,
    так как такая операция позволила бы записывать невычислимые
    функции.

    Несмотря на то что общие невычислимые свойства не могут быть
    выражены как булевы вычисления, стоит заметить, что даже
    многие _вычислимые_ свойства легче выразить используя [Prop] а не
    [bool], так как определения рекурсивных функций существенно
    ограничены в Coq. Например, следующая глава показывающая как
    определить свойство регулярных выражений, которые соответствуют
    заданной строке, используя [Prop]. Для того чтобы сделать тоже
    используя [bool] потребует написание разборщика регулярных выражений,
    который будет более сложным, труднее для понимания и сложнее
    рассуждать об.

    Обратно, важнная побочная польза от формулирования фактов
    с использованием булевых значений заключается в возможности
    некоторой автоматизации доказательства через вычисления
    с термами Coq, техника известная как _доказательство
    по рефлексии_. Рассмотрим следующее утверждение: *)

Example even_1000 : exists k, 1000 = double k.

(** Наиболее прямой способ доказательства это просто предоставить значение [k]
    напрямую. *)

 Proof. exists 500. reflexivity. Qed.

(** С другой стороны доказательство соответствующего булева утверждения
    еще проще: *)

Example even_1000' : evenb 1000 = true.
Proof. reflexivity. Qed.

(** Что интересно, так это то что оба понятия эквивалентны,
    мы можем использовать булеву формулировку для доказательство
    другой формулировки, без явного упоминания 500: *)

Example even_1000'' : exists k, 1000 = double k.
Proof. apply even_bool_prop. reflexivity. Qed.

(** Несмотря на то что мы не получили выгоды в терминах размера
    доказательства в данном случае, более крупные доказательства
    могут быть часто сделаны значительно проще с использованием
    рефлексии. Как экстремальный случай, доказательство Coq знаменитой
    _теоремы о четырех красках_ использует рефлексию для редуцирования
    анализа сотен различных случаев к булевым вычислениям. Мы не будем
    обсуждать рефлексию в деталях, но она служит хорошим примером
    показывающим комплементарные сильные стороны булевых и общих
    пропозиций. *)

(** **** Упражнение: 2 звездочки (logical_connectives)  *)
(** Следующие леммы связывают пропозициональные связки изученные в данной
    главе и соответствующие булевы операции. *)

Lemma andb_true_iff : forall b1 b2:bool,
  b1 && b2 = true <-> b1 = true /\ b2 = true.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
  
Lemma orb_true_iff : forall b1 b2,
  b1 || b2 = true <-> b1 = true \/ b2 = true.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** **** Упражнение: 1 звездочка (beq_nat_false_iff)  *)
(** Следующая теорема есть альтернативная "негативная" форулировка
    [beq_nat_true_iff] которая более удобна в некоторых ситуациях.
    (вы увидете примеры в последующих главах). *)

Theorem beq_nat_false_iff : forall x y : nat,
  beq_nat x y = false <-> x <> y.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.                                                               
(** [] *)

(** **** Упражнение: 3 звездочки (beq_list)  *)
(** Имея булев оператор [beq] для тестирования на равенство элементов
    некоторого типа [A], мы можем определить функцию [beq_list beq] для
    тестирования на равенство списков из элементов [A]. Завершите определение
    функции [beq_list] внизу. Для того чтобы убедиться что ваше
    определение корректно, докажите лемму [beq_list_true_iff]. *)

Fixpoint beq_list {A} (beq : A -> A -> bool)
                  (l1 l2 : list A) : bool 
  (* ЗАМЕНИТЕ ЭТУ СТРОКУ НА   := _ваше определение_ . *) . Admitted.

Lemma beq_list_true_iff :
  forall A (beq : A -> A -> bool),
    (forall a1 a2, beq a1 a2 = true <-> a1 = a2) ->
    forall l1 l2, beq_list beq l1 l2 = true <-> l1 = l2.
Proof.
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** **** Упражнение: 2 звездочки, рекомендовано (All_forallb)  *)
(** Вспомните функцию [forallb], из упражнения
    [forall_exists_challenge] главы [Тактики]: *)

Fixpoint forallb {X : Type} (test : X -> bool) (l : list X) : bool :=
  match l with
  | [] => true
  | x :: l' => andb (test x) (forallb test l')
  end.

(** Докажите следующую теорему связывающую [forallb] со свойством [All]
    предыдущего упражнение. *)

Theorem forallb_true_iff : forall X test (l : list X),
   forallb test l = true <-> All (fun x => test x = true) l.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** Есть ли какие либо другие важные свойства функции [forallb] которые
    не зафиксированы вашей спецификацией? *)

(* ЗАПОЛНИТЕ ЗДЕСЬ *)
(** [] *)

(* ================================================================= *)
(** ** Классическая и Конструктивная Логики *)

(** Мы видели что невозжножно протестировать справедливо или нет
    пропозиция [P] когда определяешь функцию в Coq. Вы можете быть
    удивлены узнав что такое же ограничение касается _доказательств_!
    Другими словами, следующий интуитивный принцип вывода не
    выводим в Coq: *)

Definition excluded_middle := forall P : Prop,
  P \/ ~ P.

(** Чтобы понять операционно очему это так, вспомните что чтобы
    доказать утверждение в форме [P \/ Q], мы используем тактики [left]
    и [right], которые эффективно требуют знания какая сторона дизнъюнкции
    имеет место. Тем не меннне, универсально квантифицированное [P] в
    [excluded_middle] есть _произвольная_ пропозиция, о которой мы
    ничего не знаем. У нас нет достаточно информации, чтобы выбрать
    для применения [left] или [right], также как и Coq не обладает
    достаточной информацией чтобы механически определить справедливо ли [P]
    или нет внутри функции. С другой стороны, если бы мы знали что [P] 
    отражен в некотором булевом терме [b], то знание ее справедливости или
    обратного стало бы тривиальным: нам бы просто надо было бы проверит0
    значение [b]. Это приводит к следующей теореме: *)

Theorem restricted_excluded_middle : forall P b,
  (P <-> b = true) -> P \/ ~ P.
Proof.
  intros P [] H.
  - left. rewrite H. reflexivity.
  - right. rewrite H. intros contra. inversion contra.
Qed.

(** В частности, правило исключенного третьего валидни для уравнений
    [n = m] между натуральными числами [n] и [m].

    Вы можете найти это странным, что общий принцип исключенного
    третьего не присутствует по умолчанию в; в конце концов любое
    утверждение либо справедливо либо нет. Тем не менее, есть преимущество
    не принятии этого принципа: утверждения в Coq могут делать
    более сильные заявления, чем аналогичные в стандарной математике.
    К примеру, если существует доказательство Coq того что [exists x, P x],
    то возможно явно показать значение [x] для которого мы можем
    доказать [P x] -- другими словами, каждое доказательство существования
    обязательно _конструктивно_. По этой причине, локиги вроде логики Coq,
    которые не предполагают третьего лишнего, называют
    _конструктивными логиками_. Более обычные логические системы, такие как
    ZFC, в которой принцип исключенного третьего имеет место для
    всех пропозиций, называют _классическими_.

    Следующий пример иллюстрирует почему принятие принципа исключенного
    третьего может привести к неконструктивным доказательствам: *)

(** _Заявление_: Существуют иррациональные числа [a] и [b] такие что [a ^
    b] рационально.

    _Доказательство_: Не сложно показать что [sqrt 2] иррационально.
    Если [sqrt 2 ^ sqrt 2] рационально, то достаточно взять [a = b =
    sqrt 2] и мы закончили. Иначе, [sqrt 2 ^ sqrt 2] иррационально.
    В данном случае, мы берем [a = sqrt 2 ^ sqrt 2] и
    [b = sqrt 2], так как [a ^ b = sqrt 2 ^ (sqrt 2 * sqrt 2) = sqrt 2 ^
    2 = 2].  []

    Заметили что произошло? Мы использовали принцип исключенного
    третьего для рассмотрения отдельно случаев где [sqrt 2 ^ sqrt 2]
    рационально и где нет, без знания какой из них справедлив!
    Поэтому, мы завершаем со знанием что такие [a] и [b] существуют
    но не можем определить их значения (по крайней мере,
    используя наш способ аргументации).

    Насколько конструктивная логика полезна, она имеет свои ограничение:
    Есть много утверждений которые легко могут быть доказаны в 
    классической логике, но имеют гораздо более сложные конструктивные
    доказательства, и также известны некоторые которые не имеют 
    никакого конструктивного доказательства! К счастью, как
    функциональная расширяемость, принцип исключенного третьего,
    совместим с логикой Coq, позволяя нам безопасно добавить его
    как аксиому. Тем не менне, нам нет необходимсти делать это
    в данной книге: результаты которые мы затрагиваем могут быть
    получены полностью в рамках конструктивной логики с лишь
    небольшой ценой за это.

    Понимание каких техник доказательства стоит избегать в конструктивном
    выводе приходит с практикой, но аргумент от противного, в частности
    знамениты тем что приводят к неконструктивным доказательствам. Вот
    типичный пример: предположим что мы хотим показать что существует [x]
    с некоторым свойством [P], т.е., такое что [P x]. Мы начнем, что
    предположим что оно ложь, т.е. [~ exists x, P x]. Из этой предпосылки,
    не сложно вывести [forall x, ~ P x]. Если мы сможем из этого промежуточного
    факта вывести противоречие, мы приходим к доказательству существования
    без того чтобы вообще продемоснтрировать значение [x] для которого
    [P x] справедливо!

    Техническая проблемя здесь, с точки зрения конструктивного подхода,
    то что мы заявляем что доказали [exists x, P x] используя доказательство [~ ~ exists
    x, P x]. Тем не менее, позволяя себе удалить двойное отрицание для
    любых утверждений эквивалентно принятию принципа исключенного третьего,
    как это показано в одном из упражнений в дальнейшем. Таким образом,
    такой способ вывода не может быть закодирован в Coq без предположения
    дополнительных аксиом. *)

(** **** Упражнение: 3 звездочки (excluded_middle_irrefutable)  *)
(** Непротиворечивость Coq с добавленным общим принципом исключенного
    третьего как аксиомой требует сложных рассуждений которые не могут быть
    проведены непосредственно в самом Coq. Тем не меннее, следующая теорема 
    утверждает что всегда безопасно предполагать аксиому разрешаемости (т.е.,
    инстанцию исключенного третьего) для каждой _конкретной_ Prop [P]. Почему?
    Потому что мы не можем доказать отрицание такой аскиомы; если бы мы могли,
    мы бы имели как [~ (P \/ ~P)] так и [~ ~ (P \/ ~P)], что есть противоречие. *)

Theorem excluded_middle_irrefutable:  forall (P:Prop),
  ~ ~ (P \/ ~ P).
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted. 

  
(** **** Упражнение: 3 звездочки, дополнительное (not_exists_dist)  *)
(** В теореме классической логике данные два высказывания эквивалентны:

    ~ (exists x, ~ P x)
    forall x, P x

    Теорема [dist_not_exists] доказывает одну сторону данной эквивалентности.
    Интересно что обратное направление не может быть доказано в
    конструктивной логике. Ваша работа показать, что она требует исключенного
    третьего. *)

Theorem not_exists_dist :
  excluded_middle ->
  forall (X:Type) (P : X -> Prop),
    ~ (exists x, ~ P x) -> (forall x, P x).
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** **** Упражнение: 5 звездочке, продвинутое, дополнительное (классические аксиомы)  *)
(** Для тех кто любит вызовы, вот упражнение взятое из книги
    Coq'Art авторов Bertot и Casteran (p. 123). Каждое из следующих
    четырех утверждений, вместе с [excluded_middle], может быть
    рассмотрено как характеризующее классическую логику. Мы не можем
    доказать какое либо из них в Coq, но мы можем последовательно добавлять
    любое из них как аксиому, в случае если хотим работать с классической логикой.

    Докажите что все эти утверждения (данные четыре плюс
    [excluded_middle]) эквивалентны. *)

Definition peirce := forall P Q: Prop,
  ((P->Q)->P)->P.

Definition double_negation_elimination := forall P:Prop,
  ~~P -> P.

Definition de_morgan_not_and_not := forall P Q:Prop,
  ~(~P /\ ~Q) -> P\/Q.
  
Definition implies_to_or := forall P Q:Prop,
  (P->Q) -> (~P\/Q).

(* ЗАПОЛНИТЕ ЗДЕСЬ *)
(** [] *)

(** $Date: 2015-08-11 12:03:04 -0400 (Tue, 11 Aug 2015) $ *)
