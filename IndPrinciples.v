(** * IndPrinciples: Принципы Индукции *)

(** Помня о соответствии Curry-Howard и ее реализации в Coq, мы теперь
    глубже рассмотрим принципы индукции. *)

Require Export ProofObjects.

(* ################################################################# *)
(** * Основы *)

(** Каждый раз объявляя новый индуктивный тип [Inductive], Coq
    автоматически генерирует _принцип индукции_ для этого типа.
    Данный принцип индукции является такой же теоремой, как и
    любая другая: Если [t] определенно индуктивно, соответствующий
    принцип индукции называется [t_ind]. Вот один для натуральных чисел: *)

Check nat_ind.
(*  ===> nat_ind :
           forall P : nat -> Prop,
              P 0  ->
              (forall n : nat, P n -> P (S n))  ->
              forall n : nat, P n  *)

(** Тактика [induction] есть просто прямая обертка, которая в своей
    основе, просто делает [apply t_ind]. Чтобы увидеть это более
    ясно, давайте поэкспериментируем с прямым использованиме [apply nat_ind],
    вместо тактики [induction] в нескольких доказательствах.  Вот, например,
    альтернативное доказательство теоремы, которую мы видели в главе
    [Basics]. *)

Theorem mult_0_r' : forall n:nat,
  n * 0 = 0.
Proof.
  apply nat_ind.
  - (* n = O *) reflexivity.
  - (* n = S n' *) simpl. intros n' IHn'. rewrite -> IHn'.
    reflexivity.  Qed.

(** Доказательство фактически такое же как и предыдущее, но некоторые
    малые отличия достойны внимания.

    Во первых, в индуктивном шаге доказательства (случай ["S"]), нам
    приходится сделать некоторую работу руками, а имено, ([intros]) которыеt
    [induction] делает автоматически.

    Во вторых, мы не вводим [n] в контекст до того как применили
    [nat_ind] -- заключение [nat_ind] содержит квантор всеобщности,
    и [apply] требует чтобы данное заключение в точности соотвествовало
    форме цели, включая квантор. В отличие, тактика [induction] работает
    как с переменной в контексте, так и переменной за квантором в цели.

    Данные удобства делают [induction] удобнее для использования в 
    практике по сравнению с применением принципов индукции вроде 
    [nat_ind] напрямую. Но также важно понять, что выкинув все
    эти удобства дополнительной обработки, мы на самом деле
    применяем [nat_ind]. *)

(** **** Упражнение: 2 звездочки, дополнительное (plus_one_r')  *)
(** Завершите данное доказательство без использования тактики [induction]. *)

Theorem plus_one_r' : forall n:nat,
  n + 1 = S n.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** Coq генерирует принципы индукции для любого типа данных, определенного
    с помощью [Inductive], включая те что не реккурсивны.  Несмотря на то,
    что нам нет необходимости в индукции для доказательства свойств
    нереккурсивных типов данных, идея принципа индукции всеже имеет
    для них смысл: он предоставляет способ доказать что свойство
    имеет место для всех значений данного типа.

    Данные сгенерированные принципы следуют согласно схожему шаблону.
    Если мы определяем тип [t] с конструкторами [c1] ... [cn], Coq генерирует
    теоремы следующей формы:

    t_ind : forall P : t -> Prop,
              ... case for c1 ... ->
              ... case for c2 ... -> ...
              ... case for cn ... ->
              forall n : t, P n

    Конкретная форма каждого случая зависит от аргументов соответствующеог
    конструктора.  Прежде чем пытаться записать общее правило, рассмотрим несколько
    примеров. Во первых, пример где конструкторы не имеют аргументов: *)

Inductive yesno : Type :=
  | yes : yesno
  | no : yesno.

Check yesno_ind.
(* ===> yesno_ind : forall P : yesno -> Prop,
                      P yes  ->
                      P no  ->
                      forall y : yesno, P y *)

(** **** Упражнение: 1 звездочка, дополнительное (rgb)  *)
(** Запишите принцип индукции который будет сгенерирован Coq 
    для следующей структуры данных. Запишите ваш ответ на бумаге
    или напечатайте его в виде комментария. Затем сравните с тем
    что напечатает Coq. *)

Inductive rgb : Type :=
  | red : rgb
  | green : rgb
  | blue : rgb.
Check rgb_ind.
(** [] *)

(** Вот следующий пример, теперь с конструкторами принимающими аргументы. *)

Inductive natlist : Type :=
  | nnil : natlist
  | ncons : nat -> natlist -> natlist.

Check natlist_ind.
(* ===> (с разницей в небольшое переименование переменной)
   natlist_ind :
      forall P : natlist -> Prop,
         P nnil  ->
         (forall (n : nat) (l : natlist),
            P l -> P (ncons n l)) ->
         forall n : natlist, P n *)

(** **** Упражнение: 1 звездочка, дополнительное (natlist1)  *)
(** Предположим что мы записали верхнее определение слегка иначе: *)

Inductive natlist1 : Type :=
  | nnil1 : natlist1
  | nsnoc1 : natlist1 -> nat -> natlist1.

(** Как теперь будет выглядеть принцип индукции? *)
(** [] *)

(** Из этих примеров мы выделяем общее правило:

    - Определение типа предоставляет несколько конструкторов; каждый
      соответствует одной ветке принципа индукции.
    - Каждый конструктор [c] принимает как аргументы типы [a1] ... [an].
    - Каждый [ai] может быть либо [t] (тип данных, что мы определяем) или
      некоторый другой тип [s].
    - Соответствующий случай принципа индукции утверждает:

        - "Для всех значений [x1]...[xn] типов [a1]...[an], если [P]
          справедливо для каждого из индуктивных аргументов (каждый [xi] типа
          [t]), тогда [P] справедливо для [c x1 ... xn]".
*)

(** **** Упражнение: 1 звездочка, дополнительное (byntree_ind)  *)
(** Запишите принцип индукции который Coq сгенерирует для следующего
    типа данных.  (Опять же, запишите ваш ответ на бумаге или
    наберите его как комментарий, а зате, сравните его с тем что
    печатает Coq.) *)

Inductive byntree : Type :=
 | bempty : byntree
 | bleaf  : yesno -> byntree
 | nbranch : yesno -> byntree -> byntree -> byntree.
(** [] *)

(** **** Упражнение: 1 звездочка, дополнительное (ex_set)  *)
(** Вот принцип индукции для индуктивно определенного множества.

      ExSet_ind :
         forall P : ExSet -> Prop,
             (forall b : bool, P (con1 b)) ->
             (forall (n : nat) (e : ExSet), P e -> P (con2 n e)) ->
             forall e : ExSet, P e

    Предоставьте определение [Inductive] для [ExSet]: *)

Inductive ExSet : Type :=.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *)

(** [] *)

(* ################################################################# *)
(** * Полиморфизм *)

(** Далее, что насчет полиморфных типов данных?

    Индуктивное определение полиморфных списков

      Inductive list (X:Type) : Type :=
        | nil : list X
        | cons : X -> list X -> list X.

    очень похоже на определение для [natlist]. Основная разница состоит 
    в том, что, здесь определение _параметризовано_ на множестве [X]:
    т.е., мы определяем _семейство_ индуктивных типов [list X],
    для каждого [X].  (Заметьте что, всегда когда [list] появляется в теле
    декларации, он всегда применен к параметру [X].)
    Приницип индукции также параметризован по [X]:

      list_ind :
        forall (X : Type) (P : list X -> Prop),
           P [] ->
           (forall (x : X) (l : list X), P l -> P (x :: l)) ->
           forall l : list X, P l

    Заметьте, что _весь_ принцип индукции параметризован по
    [X].  А именно, [list_ind] может быть рассмотрен как полиморфная
    функция, которая будучи применена к типу [X], выдает нам принцип
    индукции специализированный для типа [list X]. *)

(** **** Упражнение: 1 звездочка, дополнительное (tree)  *)
(** Запишите принцип индукции который будет сгенерирован Coq
   для следующего типа данных. Сравните свой ответ с тем, что
   выдает Coq. *)

Inductive tree (X:Type) : Type :=
  | leaf : X -> tree X
  | node : tree X -> tree X -> tree X.
Check tree_ind.
(** [] *)

(** **** Упражнение: 1 звездочка, дополнительное (mytype)  *)
(** Найдите индуктивное определение которое приводит к следующему
    принципу индукции:

      mytype_ind :
        forall (X : Type) (P : mytype X -> Prop),
            (forall x : X, P (constr1 X x)) ->
            (forall n : nat, P (constr2 X n)) ->
            (forall m : mytype X, P m ->
               forall n : nat, P (constr3 X m n)) ->
            forall m : mytype X, P m
*) 
(** [] *)

(** **** Упражнение: 1 звездочка, дополнительное (foo)  *)
(** Найдите индуктивное определение которое приводит к следующему
    принципу индукции:

      foo_ind :
        forall (X Y : Type) (P : foo X Y -> Prop),
             (forall x : X, P (bar X Y x)) ->
             (forall y : Y, P (baz X Y y)) ->
             (forall f1 : nat -> foo X Y,
               (forall n : nat, P (f1 n)) -> P (quux X Y f1)) ->
             forall f2 : foo X Y, P f2
*) 
(** [] *)

(** **** Упражнение: 1 звездочка, дополнительное (foo')  *)
(** Рассмотрите следующее индуктивное определение: *)

Inductive foo' (X:Type) : Type :=
  | C1 : list X -> foo' X -> foo' X
  | C2 : foo' X.

(** Какой принцип индукции сгенерирует Coq для [foo']? Заполните
   пробелы, затем сверьте свой ответ с ответом Coq.)

     foo'_ind :
        forall (X : Type) (P : foo' X -> Prop),
              (forall (l : list X) (f : foo' X),
                    _______________________ ->
                    _______________________   ) ->
             ___________________________________________ ->
             forall f : foo' X, ________________________
*)

(** [] *)

(* ################################################################# *)
(** * Индукционные Гипотезы *)

(** Где понятие "индукционная гипотеза" рассположена во всей истории?

    Принцип индукции для чисел

       forall P : nat -> Prop,
            P 0  ->
            (forall n : nat, P n -> P (S n))  ->
            forall n : nat, P n

   есть общее утверждение которое справедливо для все пропозиций
   [P] (или скорее, строго говоря, для всех фамилий пропозиций
   [P] индексированных числом [n]). Каждый раз применян данный
   принцип, мы выбираем [P] как конкретное выражение типа [nat->Prop].

   Мы можем сделать доказательства по индукции более явными
   задавая данному выражению имя. Например, вместо утверждения
   теоремы [mult_0_r] как "[forall n, n * 0 = 0]," мы можем
   записать его как "[forall n, P_m0r n]", где [P_m0r] определенно
   как... *)

Definition P_m0r (n:nat) : Prop :=
  n * 0 = 0.

(** ... или эквивалентно: *)

Definition P_m0r' : nat->Prop :=
  fun n => n * 0 = 0.

(** Теперь легче увидеть где [P_m0r] появляется в доказательстве. *)

Theorem mult_0_r'' : forall n:nat,
  P_m0r n.
Proof.
  apply nat_ind.
  - (* n = O *) reflexivity.
  - (* n = S n' *)
    (* Обратите внимание на состояние цели в данной точке! *)
    intros n IHn.
    unfold P_m0r in IHn. unfold P_m0r. simpl. apply IHn. Qed.

(** Данный дополнительный шаг с именованием не есть то что мы делаем
    в нормальных доказательства, но полезно так сделать раз или два,
    так как это позволяет увидеть точно в чем заключается индукционная
    гипотеза.  Если мы доказываем [forall n, P_m0r n] по индукции на
    [n] (используя либо [induction] либо [apply nat_ind]), мы видем что
    первая подцель требует от нас доказать [P_m0r 0] ("[P] справедливо
    для нуля"), в то время как вторая цель требует доказательства [forall n',
    P_m0r n' -> P_m0r n' (S n')] (а именно "[P] справедливо для [S n'] если
    оно справедливо для [n']" или, более элегатно, "[P] сохраняется с [S]").
    _Индукционная гипотеза_ есть предпосылка данное последней импликации
     -- утверждения того что [P] справедливо для [n'], которое мы имеем
    право использовать для доказательства того, что [P] справедливо для [S n']. *)

(* ################################################################# *)
(** * Больше о Тактике [induction] *)

(** Тактика [induction] на самом деле делает больше низкоуровневых
    действий для нашего удобства чем тем что мы обсудили сверху.

    Вспомните неформальное изложение принципа индукции для натуральных
    чисел:
      - Если [P n] есть некоторая пропозиция включающая натуральное число n,
        и мы хотим показать что P справедливо для _всех_ чисел n, мы можем
        рассуждать следующим образом:
          - показать что [P O] имеет место
          - показать что, если [P n'] справедливо, то также имеет место [P (S n')]
          - заключить чтп [P n] справедливо для всех n.
    Таким образом, когда мы начинаем доказательство с [intros n] а затем [induction n],
    мы сначало говорим Coq рассмотреть _конкретное_ [n] (введя его в контекст)
    а затем просим доказать нечто о _всех_ числах (используя индукцию).

    Что Coq на самом деле делает в данной ситуации, внутренне, это
    "переобобщает" переменную на которой мы производим индукцию. Например,
    в оригинальном доказательстве того что [plus] ассоциативен... *)

Theorem plus_assoc' : forall n m p : nat,
  n + (m + p) = (n + m) + p.
Proof.
  (* ...мы вначале вводим все 3 переменные в контекст,
     что тоже самое что сказать " Рассмотрим произвольные [n], [m], и
     [p]..." *)
  intros n m p.
  (* ...Теперь мы используем тактику [induction] для доказательства [P n] (того
     что, [n + (m + p) = (n + m) + p]) для _всех_ [n], и таким образом
     для конкретного [n] который в контексте на данный момент. *)
  induction n as [| n'].
  - (* n = O *) reflexivity.
  - (* n = S n' *)
    (* Во второй подцели сгенерированной [induction] -- 
       "шаг индукции" -- мы должны доказать что [P n'] означает
       [P (S n')] для всех [n'].  Тактика [induction] автоматически
       вводит [n'] и [P n'] в контекст для нас, оставляя лишь
       [P (S n')] как цель. *)
    simpl. rewrite -> IHn'. reflexivity.  Qed.

(** Также работает применение [induction] к переменной за квантором в цели. *)

Theorem plus_comm' : forall n m : nat,
  n + m = m + n.
Proof.
  induction n as [| n'].
  - (* n = O *) intros m. rewrite <- plus_n_O. reflexivity.
  - (* n = S n' *) intros m. simpl. rewrite -> IHn'.
    rewrite <- plus_n_Sm. reflexivity.  Qed.

(** Заметьте что [induction n] оставляет [m] связанным в цели --
    т.е., то что доказываем индуктивно есть утверждение начинающееся 
    с [forall m].

    Если мы делаем [induction] на переменной за квантором в цели
    _после_ неоткорых других кванторов, тактика [induction] будет
    автоматически вводить переменные связанные с кванторами в
    контекст. *)

Theorem plus_comm'' : forall n m : nat,
  n + m = m + n.
Proof.
  (* Давайте используем индукцию по [m] сейчас, вместо [n]... *)
  induction m as [| m'].
  - (* m = O *) simpl. rewrite <- plus_n_O. reflexivity.
  - (* m = S m' *) simpl. rewrite <- IHm'.
    rewrite <- plus_n_Sm. reflexivity.  Qed.

(** **** Упражнение: 1 звездочка, дополнительное (plus_explicit_prop)  *)
(** Перепишите как [plus_assoc'] так и [plus_comm'] и их доказательства
    в том же стиле что [mult_0_r''] сверху -- т.е., для каждой теоремы
    задайте явное определение [Definition] пропозиции что должна быть доказана
    индукцией, сформулируйте теорему и доказательство в терминах
    определенных пропозиций.  *)

(* ЗАПОЛНИТЕ ЗДЕСЬ *)
(** [] *)

(* ################################################################# *)
(** * Принципы Индукции в [Prop] *)

(** Ранее, мы рассмотрели в деталях принципы индукции что Coq
    генерирует для индуктивно определенных _множеств_. Принципы
    индукции для индуктивно определенных _пропозиций_ вроде [ev] немножечко
    сложнее. Как и в случае всех принципов индукции, мы хотим
    использовать принцип индукции на [ev] для доказательства вещдей
    на основе индуктивного рассмотрения возможных форм которые имеют
    элементы в [ev].  Интуитивно, тем не менее, то что мы хотим доказать
    не утверждения о _свидетельсве_ но утверждения о
    _числах_: соответственнно, мы хотим принцип индукции который
    позволяет доказывать свойства на числах по индукции на свидетельствах.

    Например, из того что мы сказали до сих пор, вы можете ожидать 
    что индуктивное определение [ev]...

      Inductive ev : nat -> Prop :=
      | ev_0 : ev 0
      | ev_SS : forall n : nat, ev n -> ev (S (S n)).

    ...приведет к принципу индукции который будет выглядеть как...

    ev_ind_max : forall P : (forall n : nat, ev n -> Prop),
         P O ev_0 ->
         (forall (m : nat) (E : ev m),
            P m E ->
            P (S (S m)) (ev_SS m E)) ->
         forall (n : nat) (E : ev n),
         P n E

     ... так как:

     - Так как [ev] индексирован числом [n] (каждый [ev] объект [E]
       есть некоторое свидетельство того что некоторое конкретное
       число [n] четно), пропозиция [P] параметризована как [n] так и [E] --
       таким образом, принцип индукции может быть использован для
       доказательства утверждений включающих как четное число, так
       свидетельство того что оно четно.

     - Так как есть два способа предоставить свидетельство четности ([ev]
       имеет два конструктора), применение принципа индукции генерирует две
       подцели:

         - Мы должны доказать что [P] справедливо для [O] и [ev_0].

         - Мы должны доказать, всегда когда [n] есть четное число и [E]
           свидетельство его четности, что если [P] справедливо для [n] и
           [E], то оно также справедливо для [S (S n)] и [ev_SS n E].

     - Если эти подцели могут быть доказаны, тогда принцип индукции
       говорит нам что [P] справедливо для _всех_ нечетных чисел [n] и
       свидетельств [E] и четности.

    Это больше гибкости, чем нам обычно нужно: она дает нам возможность
    доказать логические утверждения где утверюдение включает свойства
    некоторого _свидетельства_ четности, в то время как все что нас заботит
    это доказательство свойств _чисел_ которые четны -- нам интересны 
    утверждения о числах, а не о свидетельстве. Было бы более удобно
    иметь принцип индукции для доказательства пропозиций [P] которые
    параметризованы лшиь [n] и чье заключение устанавливает [P] для
    всех четных чисел [n]:

       forall P : nat -> Prop,
       ... ->
       forall n : nat,
       even n -> P n

    По этой причине, Coq на самом деле генерирует следующий упрощенный
    принцип индукции для [ev]: *)

Check ev_ind.
(* ===> ev_ind
        : forall P : nat -> Prop,
          P 0 ->
          (forall n : nat, ev n -> P n -> P (S (S n))) ->
          forall n : nat,
          ev n -> P n *)

(** В частности, Coq избавился от терма свидетельства [E] как параметра
    для пропозиции [P]. *)

(** По русски, [ev_ind] утверждает:

    - Предположим, [P] есть свойство натуральных чисел (т.е., [P n] есть
      [Prop] для каждого [n]).  Чтобы показать что [P n] справедливо всегда когда [n]
      четно, достаточно показать:

      - [P] имеет место для [0],

      - для любого [n], если [n] четно и [P] справедливо для [n], тогда [P]
        справедливо для [S (S n)]. *)

(** Как ожидалось, мы можем применить [ev_ind] напрямую вместо использования
    [induction]. *)

Theorem ev_ev' : forall n, ev n -> ev' n.
Proof.
  apply ev_ind.
  - (* ev_0 *)
    apply ev'_0.
  - (* ev_SS *)
    intros m Hm IH.
    apply (ev'_sum 2 m).
    + apply ev'_2.
    + apply IH.
Qed.

(** Точная форма определения [Inductive] может повлиять на
    принцип индукции сгенерированным Coq.

    Например, в главе [IndProp], мы определили [<=] как: *)

(* Inductive le : nat -> nat -> Prop :=
     | le_n : forall n, le n n
     | le_S : forall n m, (le n m) -> (le n (S m)). *)

(** Данное определение может быть немного улучшено если обратить
    внимание, что левосторонний аргуметн [n] один и тот же всюду
    в определении, так что мы на самом деле можем сделать
    его "общим параметром" для всего определения, вместо аргуметна
    к каждому конструктору. *)

Inductive le (n:nat) : nat -> Prop :=
  | le_n : le n n
  | le_S : forall m, (le n m) -> (le n (S m)).

Notation "m <= n" := (le m n).

(** Второе определение лучше, хотя не выглядит столь симметрично.
    Почему? Потому что оно предоставляет более простой принцип
    индукции. *)

Check le_ind.
(* ===>  forall (n : nat) (P : nat -> Prop),
           P n ->
           (forall m : nat, n <= m -> P m -> P (S m)) ->
           forall n0 : nat, n <= n0 -> P n0 *)

(* ################################################################# *)
(** * Формальные и Неформальные Доказательства по Индукции *)

(** Вопрос: Каково отношение между формальным доказательством пропозиции
    [P] и неформальным доказательством той же самой пропозиции [P]?

    Ответ: Последнее должно _научить_ читателя как приготовить предыдущее.

    Вопрос: Сколько деталей нам нужно??

    К сожалению, нет одного правильного ответа; более того, есть спектр
    возможностей.

    В одном конце спектра, мы можем предоставить читателю целое формальное
    доказательство (т.е., "неформальное доказательство" просто будет
    означать переписывание формального словами).  Это предоставит читателю
    возможность воспроизвести формальное доказательство самим, но 
    скорее всего оно не _научит_ их многому.

   В другом конце спектра, мы можем сказать "Теорема справедлива и вы
   можете сообразить сами почему, если подумаете достаточно хорошо."
   Это также не самая лучшая стратегия, так как часто запись доказательства
   требует одного или нескольких значительных шагов для того чтобы
   все доказать, и большинство читателей сдадутся прежде чем переоткроют
   те же самые шаги, какие сделали авторы.

   В центре лежит золотая середина -- доказательство которое включает
   основные шаги (спасая читателя от тяжелой работы которую мы совершили
   в поиске доказательства) плюс предложения высокого уровня для более
   рутинных частей для сохранения времени читателя на востановления
   этих частей (например, что IH говорит и что должно быть показано в каждом случае
   индуктивного доказательства), но не настолько много деталей, чтобы
   скрыть основные идеи.

   Так как мы посвятили много времени в данной главе заглядыванию "под капот" 
   формальным доказательствам по индукции, то сейчас удобный момент поговорить
   ндмного про _неформальные доказательства_ по индукции.

   В реальном мире математической коммуникации, записанные доказательства
   разнятся от длинных и педантичных до крайне кратких и телеграфичных.
   Несмотря на то что идеал лежит где то посередине, пока мы только
   приобщаемся к стилю, лучше начать с более педантичного конца. Также
   во время ученического периода, также вероятно полезно иметь ясные
   стандарты для сравнения. С этим в умер, мы предлагаем два шаблона
    -- один для доказательств индукцией на _данных_ (т.е., где нечто
   на чем мы делаем индукцию живет в [Type]) и другой для индукции по
   _свидетельству_ (т.е., где индуктивно определенные вещи обитают в [Prop]). *)

(* ================================================================= *)
(** ** Индукция по Индуктовно Определенному Мноеству *)

(** _Шаблон_:

       - _Tеорема_: <Пропозиция с квантором универсальности в форме
         "Для всех [n:S], [P(n)]," где [S] есть некоторое индуктивно определенное
          множество .>

         _Доказательство_: Индукцией по [n].

           <один случай для каждого конструктора [c] для [S]...>

           - Предположим что [n = c a1 ... ak], где <... и здесь мы утверждаем
             IH для каждого из [a] что имеют тип [S], если такие есть>.
             Мы должны показать <...и здесь мы переформулируем [P(c a1 ... ak)]>.

             <идти и доказать [P(n)] для завершения случая...>

           - <oдругие случаи аналогично...>                        []

    _Пример_:

      - _Теорема_: Для всех множеств [X], списков [l : list X], и чисел
        [n], если [length l = n] тогда [index (S n) l = None].

        _Доказательство_: Индукцией по [l].

        - Предположим [l = []].  Мы должны показать что, для всех чисел [n],
          , если [length [] = n], тогда [index (S n) [] =
          None].

          Это следует непосредственно из определения [index].

        - Предположим [l = x :: l'] для некоторого [x] и [l'], где
          [length l' = n'] означает [index (S n') l' = None], для
          любого числа [n'].  Мы должны показать, что для всех [n], 
          если [length (x::l') = n] то [index (S n) (x::l') =
          None].

          Пусть [n] есть чсило с [length l = n].  Так как

            length l = length (x::l') = S (length l'),

          то достаточно показать

            index (S (length l')) l' = None.

          Это следует непосредственно из индукционной гипотезы,
          взяв [n'] равным [length l'].  [] *)

(* ================================================================= *)
(** ** Индукция на Индуктивно Определенных Пропозициях *)

(** Так как индуктивно определенные объекты доказательств часто называются
    "деревьями доказательства," данная форма доказательства также известна как
     _индукция по доказательствам_.

    _Шаблон_:

       - _Теорема_: <Пропозиция в форме "[Q -> P]," где [Q] есть
         некоторая индуктивно определенная пропозиция ( более обще,
         "Для любых [x] [y] [z], [Q x y z -> P x y z]")>

         _Доказательство_: Индукцие по доказательству [Q].  <или, более
         более обще, "Предположим нам предоставлены [x], [y], и [z]. Мы
         показываем что [Q x y z] означает [P x y z], индукцией по
         доказательству [Q x y z]"...>

           <для случая каждого конструктора [c] для [Q]...>

           - Предположим что последнее правило использованное для
             доказательства [Q] есть [c]. Тогда
             <...и здесь мы формулируем типы всех [a] вместе с любыми
             равенствами которые следуют из определения конструктора и IH
             для всех [a] которые имеют тип [Q], если таковые есть>. Мы
             должны показать <...и здесь мы переутверждаем [P]>.

             <идем и доказываем [P] для завершения случая...>

           - <все остальные случаи аналогично...>                        []

    _Пример_

       - _Теорема_: Отношение [<=] транзитивно -- т.е., для всех чисел
         [n], [m], и [o], если [n <= m] и [m <= o], тогда
         [n <= o].

         _Доказательство_: Индукцией по доказательству [m <= o].

           - Предположим последнее правило что было использовано
             для доказательства [m <= o] есть [le_n]. Тогда [m = o] 
             и мы должны показать что [n <= m], что следует непосредственно
             из гипотезы.

           - Предположим что последнее правило использованное чтобы показать [m <= o] есть
             [le_S].  Тогда [o = S o'] для некоторого [o'] с [m <= o'].
             Мы должны показать [n <= S o'].
             По индукционной гипотезе, [n <= o'].

             Но тогда, используя [le_S], [n <= S o'].  [] *)

(** $Date: 2016-07-14 17:02:35 -0400 (Thu, 14 Jul 2016) $ *)
