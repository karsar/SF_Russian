(** * Тактики: Больше Базовых Тактик *)

(** Данная глава вводит несколько новых стратегий доказательства и тактик,
    которые позволяют нам доказывать более интересные свойства
    функциональных програм. Мы увидем как:

    - использовать вспомогательные леммы как стиле доказательств "вперед" так
      в стиле "назад";
    - как рассуждать о конструкторах данных (в частности, как использовать
      тот факт, что они инъективны и непересекающиеся);
    - как создать сильную индукционную гипотезу (и когда такое усиление
      необходимо); и
    - больше деталей о том как рассуждать используя анализ случаев. *)

Require Export Poly.

(* ###################################################### *)
(** * Тактика [apply] *)

(** Мы часто встречаем ситуации, где цель что мы должны доказать
    в точности такая же как некоторая гипотеза в контексте или
    же лемма доказанная раннее. *)

Theorem silly1 : forall (n m o p : nat),
     n = m  ->
     [n;o] = [n;p] ->
     [n;o] = [m;p].
Proof.
  intros n m o p eq1 eq2.
  rewrite <- eq1.

(** В данной точке, мы можем завершить используя "[rewrite -> eq2.
    reflexivity.]" как мы делалил несколько раз до этого. Мы можем
    достичь того же результата в один шаг, используя вместо этого
    тактику [apply]: *)

  apply eq2.  Qed.

(** Тактика [apply] также работает с _условными_ гипотезами и леммами:
    если применяемое утверждение является импликацией, тогда предпосылки
    импликации будут добавлены в список подцелей для доказательств. *)

Theorem silly2 : forall (n m o p : nat),
     n = m  ->
     (forall (q r : nat), q = r -> [q;o] = [r;p]) ->
     [n;o] = [m;p].
Proof.
  intros n m o p eq1 eq2.
  apply eq2. apply eq1.  Qed.

(** Вы можете найти полезным поэкспериментировать с данным доказательством
    и посмотреть есть ли способ завершить его используя лишь [rewrite]
    вместо [apply]. *)

(** Обычно, когда мы используем [apply H], выражение [H] начинается
    с [forall] который связывает некоторые _универсальные переменные_.
    Когда Coq сопоставляет текущую цель с заключением [H], он
    попытается найти соответствующие значения для этих переменных.
    Например, когда мы делаем [apply eq2] в следующем доказательстве, 
    универсальная переменная [q] в [eq2] инстанционируется [n] и [r]
    инстанционируется [m]. *)

Theorem silly2a : forall (n m : nat),
     (n,n) = (m,m)  ->
     (forall (q r : nat), (q,q) = (r,r) -> [q] = [r]) ->
     [n] = [m].
Proof.
  intros n m eq1 eq2.
  apply eq2. apply eq1.  Qed.

(** **** Упражнение: 2 звездочки, дополнительное (silly_ex)  *)
(** Завершите следующее доказательство без использования [simpl]. *)

Theorem silly_ex :
     (forall n, evenb n = true -> oddb (S n) = true) ->
     evenb 3 = true ->
     oddb 4 = true.
Proof.
  (* ЗАПОЛНИТЪ ЗДЕСЬ *) Admitted.
(** [] *)

(** Для использования тактики [apply], заключение применяемого факта
    должно соответствовать цели в точности -- например, [apply]
    не сработает если правые и левые части равенства переставлены. *)

Theorem silly3_firsttry : forall (n : nat),
     true = beq_nat n 5  ->
     beq_nat (S (S n)) 7 = true.
Proof.
  intros n H.
  simpl.
  (* Здесь мы не можем применить тактику [apply] напрямую *)
Abort.

(** В этом случае мы можем использовать тактику [symmetry], которая переставляет
    правые и левые стороны равенства в цели. *)

Theorem silly3 : forall (n : nat),
     true = beq_nat n 5  ->
     beq_nat (S (S n)) 7 = true.
Proof.
  intros n H.
  symmetry.
  simpl. (* На самом деле, тут нет необходимости в [simpl], так как
            [apply] сначало произведет упрощение. *)
  apply H.  Qed.

(** **** Упражнение: 3 звездочки (apply_exercise1)  *)
(** (_Подсказка_: Вы можете применять [apply] с ранее определенными леммами, а не
    только гипотезами из контекста.  Помните о том, что [SearchAbout] ваш друг.) *)

Theorem rev_exercise1 : forall (l l' : list nat),
     l = rev l' ->
     l' = rev l.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** **** Упражнение: 1 звездочка, дополнительное (apply_rewrite)  *)
(** Кратко обясните разницу между тактиками [apply] и
    [rewrite].  Каковы ситуации, в которых обе могут быть применены
    с пользой?

(* ЗАПОЛНИТЬ ЗДЕСЬ *)
*)
(** [] *)

(* ###################################################### *)
(** * Тактика [apply ... with ...] *)

(** Следующий глупый пример использует два переписывания, чтобы
    получить из [[a,b]] выражение [[e,f]]. *)

Example trans_eq_example : forall (a b c d e f : nat),
     [a;b] = [c;d] ->
     [c;d] = [e;f] ->
     [a;b] = [e;f].
Proof.
  intros a b c d e f eq1 eq2.
  rewrite -> eq1. rewrite -> eq2. reflexivity.  Qed.

(** Так как это типичный паттерн, мы можем выделить его в качестве леммы,
    раз и навсегда, как транзитивность равенства. *)

Theorem trans_eq : forall (X:Type) (n m o : X),
  n = m -> m = o -> n = o.
Proof.
  intros X n m o eq1 eq2. rewrite -> eq1. rewrite -> eq2.
  reflexivity.  Qed.

(** Теперь, у нас есть транзитивность [trans_eq] для того чтобы доказать вышеприведенный пример.
    Тем не менее, для того чтобы сделать это, нам нужно слегка уточнить нашу тактику [apply]. *)

Example trans_eq_example' : forall (a b c d e f : nat),
     [a;b] = [c;d] ->
     [c;d] = [e;f] ->
     [a;b] = [e;f].
Proof.
  intros a b c d e f eq1 eq2.

(** Если мы просто скажем Coq применить [apply trans_eq] в данной точке,
    он сможет понять ( сопосоставляя цель с заключением леммы)
    что он должен инстанционировать [X] [[nat]]ом, [n] соотвественно [[a,b]]ом,
    и [o] [[e,f]]ом.  Тем  не менее, сопоставление не определяет
    инстанциацию для [m]: мы должны в явном виде предоставить ее
    добавив [with (m:=[c,d])] в вызов [apply]. *)

  apply trans_eq with (m:=[c;d]). apply eq1. apply eq2.   Qed.

(** На самом деле, мы обычно не должны предоставлярь имя [m] в
    выражении [with]; Coq часто достаточно умен, чтобы понять
    инстанциацию чего мы предоставляем. Мы могли бы написать взамен: 
    [apply trans_eq with [c;d]]. *)

(** **** Упражнение: 3 звездочки, дополнительное (apply_with_exercise)  *)
Example trans_eq_exercise : forall (n m o p : nat),
     m = (minustwo o) ->
     (n + p) = m ->
     (n + p) = (minustwo o).
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(* ###################################################### *)
(** * Тактика [inversion] *)

(** Вспомните определение натуральных чисел:

     Inductive nat : Type :=
       | O : nat
       | S : nat -> nat.

    Из обределения очевидно, что любое число имеет одну из двух форм:
    оно либо конструктор [O] или построено применением конструктора 
    [S] к другому числу.  Но здесь содержится больше чем кажется на
    первый взгляд: неявно в определении (и в нашем неформальном
    понимании того как декларация структуры данных работает в
    других языках программирования) заложены два дополнительных
    факта:

    - Конструктор [S] _инъективен_.  Т.е., если [S n = S m], то
      должно быть что [n = m].

    - Конструкторы [O] и [S] _непересекающиеся_.  Т.е., [O] не равен
      [S n] для любого [n]. *)

(** Похожие принципы применимы ко всем индуктивно определенным типам:
    все конструкторы инъективну, и все значения построенные из разных
    конструкторов никогда не равны. Для списков, конструктор [cons]
    инъективен и [nil] отличен от непустого списка. Для булевых
    значений, [true] и [false] различны.  (Так как ни [true] ни [false]
    не принимают каких либо аргументов, их вопрос их инъективности
    не имеет смысла.)  И так далее. *)

(** Coq предоставляет тактику (инверсия) [inversion] которая позволяет
    использовать данные принципы в доказательствах. Чтобы увидеть как
    ее можно использовать, покажем явно что конструктор [S] инъективен: *)

Theorem S_injective : forall (n m : nat),
  S n = S m ->
  n = m.
Proof.
  intros n m H.

(** Записывая [inversion H] в данном месте, мы просим Coq сгенерировать
    все равенства, что он сможет вывести из [H] в качестве дополнительных
    гипотез, заменяя переменные в цели по ходу действия. В данном примере,
    это выражается в добавлении новой гипотезы [H1 : n =
    m] и замене [n] на [m] в цели. *)

  inversion H. reflexivity.  Qed.

(** Вот еще более интересный пример, показывающий как несколько
    равенств могут быть выведены за один раз. *)

Theorem inversion_ex1 : forall (n m o : nat),
  [n; m] = [o; o] ->
  [n] = [m].
Proof.
  intros n m o H. inversion H. reflexivity. Qed.

(** Имеется возможность задать имена равенствам которые генерирует
    [inversion] используя [as ...] условие: *)

Theorem inversion_ex2 : forall (n m : nat),
  [n] = [m] ->
  n = m.
Proof.
  intros n o H. inversion H as [Hno]. reflexivity.  Qed.

(** **** Упражнение: 1 звездочка (inversion_ex3)  *)
Example inversion_ex3 : forall (X : Type) (x y z : X) (l j : list X),
  x :: y :: l = z :: j ->
  y :: l = x :: j ->
  x = y.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** В то время как инъективность конструкторов позволяет рассуждать
    о том что [forall (n m : nat), S n = S m -> n = m], обратное к
    данной импликации есть следствие более общего факта о конструкторах
    и функциях, что мы найдем полезным далее: *)

Theorem f_equal : forall (A B : Type) (f: A -> B) (x y: A),
  x = y -> f x = f y.
Proof. intros A B f x y eq. rewrite eq.  reflexivity.  Qed.

(** Когда использована на гипотезе включающей равенство между
    _разными_ конструкторами (например, [S n = O]), [inversion] 
    сразу достигает цели. Чтобы увидеть почему это имеет смысл,
    рассмотрим следующее доказательство: *)

Theorem beq_nat_0_l : forall n,
   beq_nat 0 n = true -> n = 0.
Proof.
  intros n.

(** Мы можем продолжить анализом случаев на [n]. Первый случай
    тривиален. *)

  destruct n as [| n'].
  - (* n = 0 *)
    intros H. reflexivity.

(** Тем не менее, второй не выглядит таким простым: предполагая
    [beq_nat 0 (S n') = true], мы должны показать [S n' = 0], но последнее
    явно противоречиво!  Способ продвинуться дальше заключается в предположении.
    После упрощение состояния цели, мы видим что [beq_nat 0 (S n') =
    true] стал [false = true]: *)

  - (* n = S n' *)
    simpl.

(** Если мы используем [inversion] на данной гипотезе, Coq заметит, что
    подцель над которой мы работаем невозможна, и таким образом
    удаляет ее из дальнейшего рассмотрения. *)

    intros H. inversion H. Qed.

(** Это часть общего логического принципа известного как
     _principle of explosion_, который утверждает, что из
    противоречия следует что угодно, даже ложь. Например: *)

Theorem inversion_ex4 : forall (n : nat),
  S n = O ->
  2 + 2 = 5.
Proof.
  intros n contra. inversion contra. Qed.

Theorem inversion_ex5 : forall (n m : nat),
  false = true ->
  [n] = [m].
Proof.
  intros n m contra. inversion contra. Qed.

(** Если вы находите данный принцип сбивающим с толку, помните,
    что данные доказательства не показывают, что заключение справедливо.
    На самом деле, они аргументируют, что ситуация описанная в предпосылках
    никогда не возникает. Мы рассмотрим данный принцип более детально
    в следующей главе. *)

(** **** Упражнение: 1 звездочка (inversion_ex6)  *)
Example inversion_ex6 : forall (X : Type)
                          (x y z : X) (l j : list X),
  x :: y :: l = [] ->
  y :: l = z :: j ->
  x = z.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** Для того чтобы суммировать обсужденное, предположим [H] это гипотеза
    в контексте или ранее доказанная лемма, в форме

      c a1 a2 ... an = d b1 b2 ... bm

    для некоторых конструкторов [c] и [d] и аргументов [a1 ... an] и
    [b1 ... bm].  Тогда [inversion H] имеет следующий эффект:

    - если [c] и [d] это один и тот же конструктор, тогда, следуя
      инъективности данного конструктора. ме знаем, что [a1 = b1], [a2 =
      b2], и т.д.; [inversion H] добавляет данные факты в контекст, и
      пытается использовать их для того чтобы переписать цель.

    - если [c] и [d] разные конструкторы, тогда гипотеза
      [H] противоречива, и данная цель не должна быть рассмотрена.
      В данном случае, [inversion H] маркирует текущую цель
      как завершенную и удаляет ее из стека целей. *)


(* ###################################################### *)
(** * Используем Тактики на Гипотезах *)

(** По умолчанию, большинство тактик рабоает над формулой цели и
    оставляет контекст неизменным. Тем не менее, большинство
    тактик также имеют вариан, который производит теже операции
    на утверждениях контекста.

    Например, тактика [simpl in H] производит упрощение в гипотезе
    с именем [H] находящейся в контексте. *)

Theorem S_inj : forall (n m : nat) (b : bool),
     beq_nat (S n) (S m) = b  ->
     beq_nat n m = b.
Proof.
  intros n m b H. simpl in H. apply H.  Qed.

(** Аналогично, [apply L in H] сравниает некоторое условное утверждение
    [L] (формы [L1 -> L2], скажем) с гипотезой [H] в контексте.
    Тем не менее, в отличие от обычного [apply] (которая переписывает цель
    сопостовляя [L2] подцели [L1]), [apply L in H] сопоставляет [H]
    против [L1] и, если удачно, то заменяет ее на [L2].

    Другими словами, [apply L in H] предоставляет нам форму "вывода
    с движением вперед": из [L1 -> L2] и гипотезы соответствующей [L1],
    она производит гипотезу соответствующую [L2].  В отличие, [apply L]
    есть по сути "вывод с движением назад": она говорит что мы если мы знаем
    [L1->L2] и мы пытаемся доказать [L2], то достаточно доказать [L1].

    Вот вариант доказательства приведенного ранее, с использованием вывода
    в движущегося вперед, вместо использованного ранее вывода назад. *)

Theorem silly3' : forall (n : nat),
  (beq_nat n 5 = true -> beq_nat (S (S n)) 7 = true) ->
  true = beq_nat n 5  ->
  true = beq_nat (S (S n)) 7.
Proof.
  intros n eq H.
  symmetry in H. apply eq in H. symmetry in H.
  apply H.  Qed.

(** Вывод вперед начинается с того что _дано_ (предпосылки,
    ранее доказанные теоремы) и интерактивно выводит заключения из них
    пока цель не достигнута. Вывод в обратном направлении начинается
    с _цели_, и итеративно рассуждает о том что может привести к цели
    пока предпосылки или доказаннанные теоремы не достигнуты.
    Если вы видели неформальные доказательства ранее (например, в
    классе математики или информатики), они вероятно использовали вывод 
    в направлении вперед. В общем, идиоматическое применение Coq 
    более склонно к обраному выводу, но в некоторых ситуациях
    вывод вперед легче осуществить.  *)

(** **** Упражнение: 3 звездочки, рекомендованное (plus_n_n_injective)  *)
(** Попрактикуйтесь в использовании "in" вариантов в данном упражнении.  
    (Подсказка: используйте [plus_n_Sm].) *)

Theorem plus_n_n_injective : forall n m,
     n + n = m + m ->
     n = m.
Proof.
  intros n. induction n as [| n'].
    (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(* ###################################################### *)
(** * Варьируем Индукционную Гипотезу *)

(** Иногда важно контроллировать конкретную форму индукционной гипотезы
    в процессе использования доказательства по индукции в Coq.
    В частности, нам необходимо было быть осторожным по поводу
    предположений которые мы переносим (используя [intros]) из цели в 
    контекст прежде чем вызывать тактику [induction]. Например, предположим
    что мы хотим показать что функция [double] инъективна -- т.е.,
    что она всегда отображает разные аргументы в разные результаты:

    Theorem double_injective: forall n m, 
      double n = double m -> n = m.

    _Начало_ данного доказательства немного деликатно: если мы начнем с

      intros n. induction n.

    все хорошо.  Но если мы начнем с
      intros n m. induction n.

    мы застрянем посередине индуктивного случая... *)

Theorem double_injective_FAILED : forall n m,
     double n = double m ->
     n = m.
Proof.
  intros n m. induction n as [| n'].
  - (* n = O *) simpl. intros eq. destruct m as [| m'].
    + (* m = O *) reflexivity.
    + (* m = S m' *) inversion eq.
  - (* n = S n' *) intros eq. destruct m as [| m'].
    + (* m = O *) inversion eq.
    + (* m = S m' *)  apply f_equal.

(** В даный момент, индукционная гипотеза, [IHn'], не дает нам
    [n' = m'] -- в ней есть лишний  [S], стоящий на нашем пути -- и цель
    недоказуема. *)

      Abort.

(** Что пошло не так? *)

(** Проблема заключается в том, что в момент вызова индукционной гипотезы
    , мы уже ввели [m] в контекст -- интуитивно, мы сказали, "Рассмотри
    некоторые конкретные [n] и [m]..." и нам теперь нужно доказать, что если
    [double n = double m] для _этих конкретных_ [n] и [m], тогда [n = m].

    Следующая тактика, [induction n] говорит Coq: Мы собираемся показать цель
    индукцией по [n]. Т.е., мы собираемся доказать, для _всех_ [n], что
    утверждение

      - [P n] = "если [double n = double m], то [n = m]"

    справедливо, показав

      - [P O]

         (т.е., "если [double O = double m] то [O = m]") и

      - [P n -> P (S n)]

        (т.е., "если [double n = double m] то [n = m]" приводит к "если
        [double (S n) = double m] то [S n = m]").

    Если мы посмотрим внимательнее на второе утверждение, оно говорит нечто
    довольно странное: оно утверждает, что для _конкретного_ [m], если мы знаем

      - "если [double n = double m] то [n = m]"

    тогда мы можем доказать

       - "если [double (S n) = double m] то [S n = m]".

    Чтобы увидеть почему это станно, давайте подумаем о конкретном [m] --
    скажем, [5]. Данное утверждение тогда говорит, что если мы знаем

      - [Q] = "если [double n = 10]  тогда [n = 5]"

    то мы можем доказать

      - [R] = "если [double (S n) = 10] то [S n = 5]".

    Но знание [Q] не дает нам никакой помощи в доказательсве
    [R]!  (Если бы мы попробовали бы доказать [R] из [Q], мы бы начали
    с чего то вроде "Предположим [double (S n) = 10]..." но затем мы 
    застрянем: зная что [double (S n)] есть [10] ничего нам не говорит
    о том является ли [double n] [10], так что [Q] бесполезна.) *)

(** Подводя итоги: Попытка доказать с помощью индукции по [n]
    когда [m] уже в контексте не работает, потому что мы пытаемся
    доказать отношение включающее _каждое_ [n] но только 
    _один_ [m]. *)

(** Хорошее доказательство [double_injective] оставляет [m] в утверждении 
    цели в тот момент когда вызвыается тактика [induction] на
    [n]: *)

Theorem double_injective : forall n m,
     double n = double m ->
     n = m.
Proof.
  intros n. induction n as [| n'].
  - (* n = O *) simpl. intros m eq. destruct m as [| m'].
    + (* m = O *) reflexivity.
    + (* m = S m' *) inversion eq.

  - (* n = S n' *) simpl.

(** Заметьте что как цель так и индукционная гипотеза различны в данном
    случае: цель просит доказать что то более общее (т.е доказать
    утверждение для _любого_ [m]), но IH соответственно более гибкая,
    позволяя выбрать любой [m] какой мы захотим применяя IH. *)

    intros m eq.

(** Теперь мы выбрали конкретный [m] и ввели предположение о том чтоa
    [double n = double m].  Так как мы делаем анализ случаев по
    [n], нам также нужен анализ случаев по [m], чтобы держать их в 
    "синхронности." *)

    destruct m as [| m'].
    + (* m = O *) simpl.

(** Случай 0 тривиален: *)

      inversion eq.

    + (* m = S m' *)
      apply f_equal.

(** В данной точке, так как мы во второй ветке [destruct
    m], [m'] упомянутый в контексте есть предшественник
    [m] с которого мы начали разговор. Так как мы также имеем [S]
    ветку индукции, это отлично: если мы заменим общий [m] в IH 
    текущим [m'] (данная инстанциация совершается автоматически
    тактикой [apply] в следующем шаге), тогда
    [IHn'] предоставляет то что нужно для завершения доказательства. *)

      apply IHn'. inversion eq. reflexivity. Qed.

(** Вывод который нужно вынести из данного примера заключается
    в том, что надо быть осторожным по отношению к индукции
    при попытке доказать что то слишком конкретное: если
    мы доказываем свойство [n] и [m] по индукции на 
    [n], может быть необходимым оставить [m] общим. *)

(** Следующее доказательство требует следования тому же шаблону. *)

(** **** Упражнение: 2 звездочки (beq_nat_true)  *)
Theorem beq_nat_true : forall n m,
    beq_nat n m = true -> n = m.
Proof.
  (* ЗАПОЛНИТЬ ЗДЕСЬ *) Admitted.
(** [] *)

(** **** Упражнение: 2 звездочки, продвинутое (beq_nat_true_informal)  *)
(** Преоставьте аккуратное неформальное доказательство [beq_nat_true], старайтесь
    выписать все про кванторы максимально детально, насколько
    это возможно. *)

(* ЗАПОЛНИТЕ ЗДЕСЬ *)
(** [] *)

(** Стратегия применения меньшего числа [intros] перед [induction] для
    получения более общего IH не всегда срабатывает сама по себе; иногда
    малая _перегруппировкаа_ переменных связанных кванторами необходима.
    Предположим, например, что мы хотим доказать [double_injective]
    по индукции на [m] вместо [n]. *)

Theorem double_injective_take2_FAILED : forall n m,
     double n = double m ->
     n = m.
Proof.
  intros n m. induction m as [| m'].
  - (* m = O *) simpl. intros eq. destruct n as [| n'].
    + (* n = O *) reflexivity.
    + (* n = S n' *) inversion eq.
  - (* m = S m' *) intros eq. destruct n as [| n'].
    + (* n = O *) inversion eq.
    + (* n = S n' *)  apply f_equal.
        (* Застряли снова как и в предыдущий раз. *)
Abort.

(** Проблема здесь в том, что для того чтобы использовать индукцию по [m],
    мы должны вначале ввести [n].  (Если мы просто используем [induction m] 
    бе звведения чего либо вначале, Coq автоматически введет [n]
    для нас!)  *)

(** Что можно в этом случае сделать?  Одна возможность заключается в
    переписывании утверждения леммы так что [m] стоит раньше [n]. Это
    сработает, но это не очень хорошо: Мы не должны быть вынуждены
    изменять выражения лемм для того чтобы удовлетворить потребности
    конкретной стратегии их доказательства -- мы хотим формулировать их
    в наиболее ясной и естественной форме. *)

(** Что мы можем сделать вместо это ввести все переменные связанные
    с кванторами и затем _переобобщить_ одну или более из них,
    селективно выбирая переменные из контекста и перемещая их
    обратно в начало цели.  Тактика [generalize dependent]
    делает это. *)

Theorem double_injective_take2 : forall n m,
     double n = double m ->
     n = m.
Proof.
  intros n m.
  (* [n] и [m] оба в контексте *)
  generalize dependent n.
  (* Теперь [n] опять в цели и мы можем проводить индукцию по
     [m] и получить достаточно общее IH. *)
  induction m as [| m'].
  - (* m = O *) simpl. intros n eq. destruct n as [| n'].
    + (* n = O *) reflexivity.
    + (* n = S n' *) inversion eq.
  - (* m = S m' *) intros n eq. destruct n as [| n'].
    + (* n = O *) inversion eq.
    + (* n = S n' *) apply f_equal.
      apply IHm'. inversion eq. reflexivity. Qed.

(** Давайте посмотрим на неформальное доказательство данной теоремы.
    Заметьте что пропозиция которую мы доказываем индукцией оставляет
    [n] с квантором всеобщности, что соответствует использованию 
    generalize dependent в нашем формальном доказательстве.

    _Теорема_: Для любых натуральных чисел [n] и [m], если [double n = double m], то
      [n = m].

    _Доказательство_: Пусть [m] есть [nat]. Мы доказываем индукцией по [m] что, для
      любых [n], если [double n = double m] то [n = m].

      - Во первых, предположим [m = 0], и предположим [n] есть число такое что
        [double n = double m].  Мы должны показать что [n = 0].

        Так как [m = 0], по определению [double] мы имеем [double n =
        0].  Есть два случая для рассмотрения в случае [n].  Если [n = 0] 
        мы закончили, так как [m = 0 = n], как и требовалось. Иначе, если [n = S n']
        для некоторого [n'], мы приходим к противоречию: по определению
        [double], мы можем посчитать [double n = S (S (double n'))], но это
        противоречит предположению [double n = 0].

      - Во вторых, предположим [m = S m'] и что [n] есть снова число такое
        что [double n = double m]. Мы должны показать что [n = S m'], с
        индукционной гипотезой о том что для каждого числа [s], если [double s =
        double m'] то [s = m'].

        Используя факт того что [m = S m'] и определение [double], мы
        имеем [double n = S (S (double m'))].  Имеются два случая для [n].

        Если [n = 0], тогда по определению [double n = 0], противоречие.

        Таким образом, мы можем утверждать что [n = S n'] для некоторого [n'], 
        и снова по определениюэ [double] мы имеем [S (S (double n')) =
        S (S (double m'))], из чего следует по инверсии что [double n' =
        double m'].  Инстанционирование индукционной гипотезы [n']ом позовляет
        нам заключить что [n' = m'], и это сразу следует из того 
        что [S n' = S m']. Так как [S n' = n] и [S m' = m], мы получаем то
        что хотели показать. [] *)

(** Прежде чем завершить данную секцию и перейти к упражнениям, 
    давайте слегка отвлечемся и используем [beq_nat_true] для доказательства
    похожего свойства для идентификаторов, которое нам понадобится
    в будущих главах: *) 

Theorem beq_id_true : forall x y,
  beq_id x y = true -> x = y.
Proof.
  intros [m] [n]. simpl. intros H.
  assert (H' : m = n). { apply beq_nat_true. apply H. }
  rewrite H'. reflexivity.
Qed.

(** **** Упражнение: 3 звездочки, рекомендованное (gen_dep_practice)  *)
(** Докажите индукцией по [l]. *)

Theorem nth_error_after_last: forall (n : nat) (X : Type) (l : list X),
     length l = n ->
     nth_error l n = None.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** **** Упражнение: 3 звездочки, дополнительное (app_length_cons)  *)
(** Докажите индукцией по [l1], без использования теоремы [app_length]
    из [Lists]. *)

Theorem app_length_cons : forall (X : Type) (l1 l2 : list X)
                                  (x : X) (n : nat),
     length (l1 ++ (x :: l2)) = n ->
     S (length (l1 ++ l2)) = n.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
 (** [] *)

(** **** Упражнение: 4 звездочки, дополнительное (app_length_twice)  *)
(** Докажите индукцией по [l], без использования [app_length] из [Lists]. *)

Theorem app_length_twice : forall (X:Type) (n:nat) (l:list X),

    length l = n ->
     length (l ++ l) = n + n.
Proof.
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** **** Упраюнение: 3 звездочки, дополнительное (double_induction)  *)
(** Докажите следующий принцип индукции по двум натуральным числам. *)

Theorem double_induction: forall (P : nat -> nat -> Prop),
  P 0 0 ->
  (forall m, P m 0 -> P (S m) 0) ->
  (forall n, P 0 n -> P 0 (S n)) ->
  (forall m n, P m n -> P (S m) (S n)) ->
  forall m n, P m n.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(* ###################################################### *)
(** * Раскрывая Определения *)

(** Иногда нам требуется вручную развернуть Definition так чтобы
    мы могли бы манипулировать его правой стороной. Например, если мы 
    определим... *)

Definition square n := n * n.

(** ... и попробуем доказать простой факт о [square]... *)

Lemma square_mult : forall n m, square (n * m) = square n * square m.
Proof.
  intros n m.
  simpl.

(** ... мы застреваем: [simpl] ничего не упрощает в этой точке,
    и так как мы не доказали никаких других фактов о [square], 
    нет ничего чтобы мы могли применить используя [apply] или [rewrite].

    Для дальнейшего прогресса, мы можем вручную раскрыть ([unfold]) 
    определение [square]: *)

  unfold square.

(** Теперь у нас есть достаточно чтобы двигаться дальше: обе части
    равенства являются выражениями использующимим умножение, и у нас
    есть мночго фактов об умножении. В частности, мы знаем, что
    оно коммутативно и ассоциативно, и из с помощью этих фактов не сложно
    закончить доказательство. *)
  
  rewrite mult_assoc.
  assert (H : n * m * n = n * n * m).
  { rewrite mult_comm. apply mult_assoc. }
  rewrite H. rewrite mult_assoc. reflexivity.
Qed.

(** На данном моменте обсудим более глубоко раскрытие и упрощение.

    Вы могли уже заметить что тактики вроде [simpl],
    [reflexivity], и [apply] часто автоматически разворачивают определения функций
    когда это позволяет добиться прогресса. Например, если мы определим 
    [foo m] как константу [5], *)

Definition foo (x: nat) := 5.

(** тогда [simpl] в следующем доказательстве (или [reflexivity], если
    мы опустим [simpl]) раскроет [foo m] в [(fun x => 5) m] и затем
    упростит его дальше до просто [5]. *)

Fact silly_fact_1 : forall m, foo m + 1 = foo (m + 1) + 1.
Proof.
  intros m.
  simpl.
  reflexivity.
Qed.

(** Тем не менее, данное автоматическое развертование достаточно консервативно.
    Например, если мы определим слегка более сложную функцию, включающую
    соответствие шаблону... *)

Definition bar x :=
  match x with
  | O => 5
  | S _ => 5
  end.

(** ...тогда аналогичное доказательство застопорится: *)

Fact silly_fact_2_FAILED : forall m, bar m + 1 = bar (m + 1) + 1.
Proof.
  intros m.
  simpl. (* Ничего не делает! *)
Abort.

(** Причина по которой [simpl] не продвигает вперед в том, что она
    замчает что, после предварительной развертки [bar m], она остается
    со сравнением,  вкотором [m] есть переменная, так что [match] не может
    упроститься дальше.  (Она недостаточно умна, чтобы заметить, что
    обе ветви [match] идентичны.)  Так что она сдается на распаковывании
    [bar m] и оставляет его как есть.  Таким же образом, предватительное
    раскрытие [bar (m+1)] оставляет как элемент соответствия [match] 
    применение функции (что, само по себе, не может быть упрощено, даже
    после раскрытия определения [+]), таким образом [simpl] оставляет 
    все как есть.

    В этом месте, есть два пути достичь прогресса. Один применить
    [destruct m] для разбиения доказательства на два случая, каждый
    сфокусированный на конкретном выборе [m] ([O] или [S _]). В каждом
    случае, [match] внутри [bar] может привести к прогрессу и
    доказательство будет легко завершить. *)

Fact silly_fact_2 : forall m, bar m + 1 = bar (m + 1) + 1.
Proof.
  intros m.
  destruct m.
  - simpl. reflexivity.
  - simpl. reflexivity.
Qed.

(** Данный подход работает, но он зависит от распознавание соответствия
    [match] спрятанного внутри [bar] которое мешает нам добиться прогресса.

    Более прямой путь завершить доказательство заключается в явном
    указании Coq распаковать [bar]. *)

Fact silly_fact_2' : forall m, bar m + 1 = bar (m + 1) + 1.
Proof.
  intros m.
  unfold bar.

(** Теперь становится ясно, что мы застряли на выражениях [match] на обеих
    сторонах [=], и мы можем использовать [destruct] для завершения
    доказательства без необходимости долго думать. *)

  destruct m.
  - reflexivity.
  - reflexivity.
Qed.

(* ###################################################### *)
(** * Использование [destruct] на Составных Выражениях *)

(** Мы увидели много примеров где [destruct] был использован
    для анализа случаев значения некоторой переменной.  Но иногда
    нам нужно рассуждать разбором случаев результата некоторого
    _выражения_. Мы также можем делать это с помощью [destruct].

    Вот несколько примеров: *)

Definition sillyfun (n : nat) : bool :=
  if beq_nat n 3 then false
  else if beq_nat n 5 then false
  else false.

Theorem sillyfun_false : forall (n : nat),
  sillyfun n = false.
Proof.
  intros n. unfold sillyfun.
  destruct (beq_nat n 3).
    - (* beq_nat n 3 = true *) reflexivity.
    - (* beq_nat n 3 = false *) destruct (beq_nat n 5).
      + (* beq_nat n 5 = true *) reflexivity.
      + (* beq_nat n 5 = false *) reflexivity.  Qed.

(** После раскрытия [sillyfun] в предыдущем доказательстве, мы обнаруживаем
    что застряли на [if (beq_nat n 3) then ... else ...]. Но либо
    [n] равен [3] либо нет, так что мы можем использовать [destruct (beq_nat
    n 3)] для того чтобы рассуждать об обоих случаях.

    В целом, тактика [destruct] может быть использована для разбора
    случаев на результатах любых вычислений. Если [e] выражение, чей
    тип есть некоторый индуктивно определенный тип [T], тогда, для
    каждого конструктора [c] типа [T], [destruct e] генерирует подцель
    в которой появления [e] (в цели и контексте) заменены на [c]. *)

(** **** Упражнение: 3 звездочки, дополнительное (combine_split)  *)
Theorem combine_split : forall X Y (l : list (X * Y)) l1 l2,
  split l = (l1, l2) ->
  combine l1 l2 = l.
Proof.
  (* ЗАПОЛНИТЬ ЗДЕСЬ *) Admitted.
(** [] *)

(** Тем не менее, [destruct]ирование составных выражений требует некоторой
    осторожности, так как [destruct]ы могут иногда стереть информацию нужную
    для завершения доказательства. *)
(** Например, предположим мы определяем функцию [sillyfun1] как: *)

Definition sillyfun1 (n : nat) : bool :=
  if beq_nat n 3 then true
  else if beq_nat n 5 then true
  else false.

(** Теперь предположим, что мы хотим убедить Coq в (довольно
    очевидном) факте того что [sillyfun1 n] приводит к [true] только
    когда [n] нечетно. По аналогии с доказательствами что приведены ранее [sillyfun],
    естественно начать доказательство следующим образом: *)

Theorem sillyfun1_odd_FAILED : forall (n : nat),
     sillyfun1 n = true ->
     oddb n = true.
Proof.
  intros n eq. unfold sillyfun1 in eq.
  destruct (beq_nat n 3).
  (* застряли... *)
Abort.

(** Мы застреваем в данном месте потому что контекст не содержит
    достаточно информации для доказательства цели!  Проблема в том
    что подстановка совершаемая [destruct] слишком груба -- она выкидывает
    все случаи [beq_nat n 3], но нам необходимо сохранить некоторую
    информацию об этом выражении и о том как оно было разбито, так
    как нам нужно будет рассуждать, что так как [beq_nat n 3 = true] в
    этой ветке разбора случаев, то должно быть [n = 3], из чего следует
    что [n] нечетно.

    Чтобы мы на самом деле хотели бы, так это заменить все имеющиеся
    случаи [beq_nat n 3], но в то же время добавить равенство в контекст
    которое фиксирует на каком случае мы находимся.  Квалификатор [eqn:]
    позволяет нам ввести такое равенство, задавая ему имя, которое мы выбрали. *)

Theorem sillyfun1_odd : forall (n : nat),
     sillyfun1 n = true ->
     oddb n = true.
Proof.
  intros n eq. unfold sillyfun1 in eq.
  destruct (beq_nat n 3) eqn:Heqe3.
  (* Теперь у нас такое же состояние, как то в котором мы застряли 
     раньше, за исключением того что контекст содержит
     дополнительное равенство, которое нам и нужно для продвижения
     вперед. *)
    - (* e3 = true *) apply beq_nat_true in Heqe3.
      rewrite -> Heqe3. reflexivity.
    - (* e3 = false *)
     (* Когда мы подходим ко второму тесту на равенство в теле
        функции, о которой мы рассуждаем, мы можем снова
        использовать [eqn:] тем же способом, что позволит
        нам дивгаться дальше. *)
      destruct (beq_nat n 5) eqn:Heqe5.
        + (* e5 = true *)
          apply beq_nat_true in Heqe5.
          rewrite -> Heqe5. reflexivity.
        + (* e5 = false *) inversion eq.  Qed.

(** **** Упражнение: 2 звездочки (destruct_eqn_practice)  *)
Theorem bool_fn_applied_thrice :
  forall (f : bool -> bool) (b : bool),
  f (f (f b)) = f b.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(* ################################################################## *)
(** * Обзор *)

(** Мы увидели много наиболее фундаментальных тактик Coq. Мы введем
    несколько дополнительных в следующих главах, а в будущем увидем
    некоторые более мощные тактики _автоматизации_ которые заставляют
    Coq помочь нам с мелкими деталями в доказательствах. Однако, мы
    уже имеем все что нам надо для наших целей.

    Вот те, которые мы уже видели:

      - [intros]: перенести гипоезы/переменные из цели в контекст

      - [reflexivity]: завершить доказательство (когда цель выглядит как [e =
        e])

      - [apply]: доказать цель используя гипотезу, лемму или конструктор

      - [apply... in H]: использовать гипотезу, лемму, или конструктор для
        гипотезы в контексте (рассуждение вперед)

      - [apply... with...]: явно задать значения переменных которые
        не могут быть определены паттерн матчингом

      - [simpl]: упростить вычисления в цели

      - [simpl in H]: ... или гипотезе

      - [rewrite]: использовать гипотезу равенства (или лемму) для переписывания
        цели

      - [rewrite ... in H]: ... или гипотезы

      - [symmetry]: менять цель формы [t=u] в [u=t]

      - [symmetry in H]: менять гипотезу формы [t=u] в 
        [u=t]

      - [unfold]: заменить определенную константу на ее правую сторону (определение)
        в цели

      - [unfold... in H]: ... в гипотезе

      - [destruct... as...]: анализ случаев на значениях индуктивно определенных
        типов

      - [destruct... eqn:...]: определить имя уравнения, которое будет
        добавлено в контекст, фиксируя результат разбора случаев

      - [induction... as...]: индукция на значениях индуктивно определенных
        типов

      - [inversion]: вывод на основе инъективности и различия конструкторов

      - [assert (e) as H]: ввести "локальную лемму" [e] и назвать ее
        [H]

      - [generalize dependent x]: переместить переменную [x] (и все остальное
        что зависит от нее) из контекста обратно в конкретную гипотезу
        формулы цели *)

(* ###################################################### *)
(** * Дополнительные Упражнения *)

(** **** Упражнение: 3 звездочки (beq_nat_sym)  *)
Theorem beq_nat_sym : forall (n m : nat),
  beq_nat n m = beq_nat m n.
Proof.
  (* ЗАПОЛНИТЬ ЗДЕСЬ *) Admitted.
(** [] *)

(** **** Упражнение: 3 звездочки, продвинутое, дополнительное (beq_nat_sym_informal)  *)
(** Предоставьте неформальное доказательство данной леммы, которое соответствуе
    вашему формальному доказательству сверху:

   Теорема: Для любых [nat]ов [n] [m], [beq_nat n m = beq_nat m n].

   Доказательство:
   (* ЗАПОЛНИТЕ ЗДЕСЬ *)
[]
*)

(** **** Упражнение: 3 звездочки, дополнительное (beq_nat_trans)  *)
Theorem beq_nat_trans : forall n m p,
  beq_nat n m = true ->
  beq_nat m p = true ->
  beq_nat n p = true.
Proof.
  (* ЗАПОЛНИТЬ ЗДЕСЬ *) Admitted.
(** [] *)

(** **** Упражнение: 3 звездочки, продвинутое (split_combine)  *)
(** Мы доказали, в упражнении сверху, что для всех списков пар,
    [combine] есть обратная для [split]. Как бы вы могли формализировать
    утверждение что [split] есть обратная к [combine]? Когда это свойство
    верно?

    Завершите определение [split_combine_statement] внизу свойством
    которое утверждает что [split] является обратным к [combine]. 
    Затем, докажите что свойство имеет место. (Убедитесь что ваша
    гипотеза достаточно обща не используя [intros] на большем числе
    вещей чем нужно. Подсказка: какое свойство вам необходимо для [l1]
    и [l2] для [split] [combine l1 l2 = (l1,l2)] было правдивым?)  *)

Definition split_combine_statement : Prop :=
(* ЗАПОЛНИТЬ ЗДЕСЬ *) admit.

Theorem split_combine : split_combine_statement.
Proof.
(* ЗАПОЛНИТЬ ЗДЕСЬ *) Admitted.


(** [] *)

(** **** Упражнение: 3 звездочки, продвинутое (filter_exercise)  *)
(** Данная часть чуть сложновата. Обратите внимание на форму вашей
    индукционной гипотезы. *)

Theorem filter_exercise : forall (X : Type) (test : X -> bool)
                             (x : X) (l lf : list X),
     filter test l = x :: lf ->
     test x = true.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** **** Упражнение: 4 звездочки, продвинутое, рекомендованное (forall_exists_challenge)  *)
(** Определите две рекурсивные [Fixpoints], [forallb] и [existsb].  Первая
    проверяет действительно ли первый элемент в списке удовлетворяет
    заданному предикату:

      forallb oddb [1;3;5;7;9] = true

      forallb negb [false;false] = true

      forallb evenb [0;2;4;5] = false

      forallb (beq_nat 5) [] = true

    Вторая проверяет действительно ли существует элемент в списке который
    удовлетворяет заданному предикату:

      existsb (beq_nat 5) [0;2;3;6] = false

      existsb (andb true) [true;true;false] = true

      existsb oddb [1;0;0;0;0;3] = true

      existsb evenb [] = false

    Дальше, определите _нерекурсивную_ версию [existsb] -- назовите ее
    [existsb'] -- используя [forallb] и [negb].

    Наконец, докажите теорему [existsb_existsb'] утверждающую, что
    [existsb'] и [existsb] ведут себя одинакого. *)

(* ЗАПОЛНИТЕ ЗДЕСЬ *)
(** [] *)

(** $Date: 2016-05-26 16:17:19 -0400 (Thu, 26 May 2016) $ *)


