(** * Предисловие: Preface.v *)

(* ###################################################################### *)
(** * Добро пожаловать! *)

(** Данная электронная книга является переводом курса _Software Foundations_, 
    посвященного математической базе лежащей в основе надежного программного 
    обеспечения. Представленный материал включает в себя
    основы логики, доказательства теорем с помощью компьютера, азы 
    формальной системы вывода Coq, функциональное программирование,
    операционную семантику, логику Хоара и статическую систему типов. 
    Уровень изложения предполагает широкий круг читателей, от продвинутых
    студентов до аспирантов и исследователей. Никакого специального знания
    в области логики или языков программирования не предполагается, 
    хотя какой либо уровень математического развития будет полезен.

    Новизна данного курса (остающаяся таковой и в данном переводе)
    в том что он на сто процентов формализован и проверен компьютером, т.е. весь
    текст буквально является скриптом в Coq. Более того, курс предназначен для чтения
    совместно с его параллельной интерактивной сессией. Для этого
    достаточно открыть этот скрипт (Preface.v) в Coq. Все детали в тексте
    полностью формализованы в Coq, и все упражнения предполагают использование
    Coq.

    Все файлы курса организованы как последовательность основных глав,
    покрывающих материал примерно одного семестра и предполагают
    последовательное линнейное изложение, плюс некоторое число "дополнений"
    посвященных дополнительным темам. Все основные главы подходят студентам
    как младших, так и старших курсов. *)


(* ###################################################################### *)
(** * Обзор *)

(** Создавать надежные программы трудно. Маштаб и сложность современных
    систем, число людей включенных в процесс их построения, и спектр
    требований к ним делают очень сложным создание даже более менее корректных программ,
    , а тем более корретных на все сто процентов.
    В то же время, степень включения обработки информации во все процессы
    в социуме все время растет, что увеличивает цену ошибок и нарушений
    в безопасности.

    Исследователи и инженеры ответили на данные вызовы созданием
    множества техник для улучшения надежности программного обеспечения,
    начиная с таких как рекомендации по менеджменту софтверных проектов и
    организации команд программистов (экстремальное программирование ...)
    до создания философий дизайна библиотек (модель-представление-контроллер, 
    публикация-подписка) и языков программировния
    (т.к. объектно ориентированные, аспектно ориентированные, 
    функциональные,..), а также, наконец, математических техниками для спецификации
    и вывода свойств программ с сопутствующими инструментами 
    помогающими им в этом.

    Данный курс сфокусирован на последнем типе методов. Текст вплетает
    в себя следующие пять важный нитей повествования:

    (1) базовые инструменты из _логики_ для построения и обоснования
        точных утверждений о программах;

    (2) использование _помощника в доказательствах_ для построения
        строгих логических аргументов;

    (3) идея _функционального программирования_, как метода программирования
        упрощающего рассуждения о программах, так и моста между 
        программированием и логикой;

    (4) формальные техники для _рассуждения о свойствах конкретных 
        программ_ (например, о том, что сортирующая функция
        или компилятор удовлетворяют некоторой формальной спецификации)

    (5) использование _системы типов_ для установления гарантий хорошего
        поведения для _всех_ программ в заданном языке программирования 
        (например, гарантии которые типы дают программам на Java во время
        исполнения).

    Каждая из данных тем достаточно богата сама по себе, чтобы служить материалом
    целого курса. Поэтому одновременное изложение всех тем означает, что многое
    останется недосказанным. Тем не менее, мы надеемся, что читатели
    обнаружат, что данные темы усиливают и подчеркивают друг друга и
    их совместное изложение создает фундамент, на основе которого
    будет легко читать более глубокие материалы в любом из направлений в дальнейшем.
    Некоторые предложения по дальнейшему чтению предоставлены в главе 
    [Postscript].
    Библиографическая информация по всем процитированным работам
    может быть найдена в главе [Bib]. *)

(** ** Логика *)

(** Логика это наука изучающая _доказательства_ -- неопровержимые
    аргументы правдивости конкретных утверждений. Многое было написано
    на тему центральной роли логики в информатике. Действительно, 
    Manna и Waldinger  назвали логику "исчислением компьютеной науки (информатики)", 
    в тоже время статья Halpern et al.'s  _On the Unusual Effectiveness 
    of Logic in Computer Science_ (О необычной эффективности
    логики в информатике) каталогизирует случаи когда логика
    предоставляет критические важные инструменты и идеи. В своей
    статье они заключают, что "Как факт, логика оказалась значительно
    более эффективной в информатике, чем в математике. Это особенно
    замечательно, с учетом того, что импульс к развитию
    логики  в течении последних ста лет приходил из математики."

    В частности, фундаментальное понятие индуктивных доказательств
    повсеместно в компьютерной науке. Вы наверняка видели его прежде,
    в контекстах от дискретной математики до анализа алгоритмов, но 
    в данном курсе мы проанализируем его гораздо глубже, чем вы наверное
    делали до сих пор. *)

(** ** Помощники в доказательствах *)

(** Поток идей между логикой и информатикой не был односторонним.
    Информатика также внесла весомый вклад в логику. Одним из
    таких вкладов была разработка программ для помощи в построении
    доказательств логических пропозиций (утверждений). Данные
    утилиты делятся на две широкие категории:

       - _Автоматические доказатели теорем_ предоставляют режим
        "нажми на кнопку":
         вы предоставляете им пропозицию и они возвращают либо _правда_,
         _ложь_, или _ran out of time_ (выход за временные ограничения).
         Несмотря на то что их возможности ограничены специальными
         видами рассуждений, они сильно развились в предыдущие годы и
         во многих случаях эффективно используются. Примерами таких
         инструментов являются SAT решатели, SMT решатели, и проверщики моделей.

       - _Помощники в доказательствах_ являются гибридными инструментами
         которые автоматизируют рутинные аспекты построения доказательств,
         при этом завися от человека в более сложных аспектах. Часто
         используемые помощники включают Isabelle, Agda, Twelf, ACL2, PVS, 
         и Coq, среди многих прочих.

    Данный курс основан вокруг Coq, помощника в доказательствах, что
    находится разработке, в основном во Франции, с 1983 года и который
    в последние годы приобрел большое сообщество пользователей как
    в академии, так в индустрии. Coq предоставляет богатую среду
    для интерактивной разработки машинно проверяеммого формального
    вывода. Ядром системы Coq служит простой проверщик доказательств, 
    который гарантирует, что были сделаны только корректные шаги дедукции.
    Поверх данного ядра, среда Coq предоставляет возможности высокого
    уровня для разработки доказательств, таких как мощные тактики для
    построения сложных доказательств полуавтоматически, и большая 
    библиотека общих определиний и лемм.

    Coq послужил критически важным инструментом в целой серии достижений
    в информатике и математике:

    - Как _платформа для моделирования языков программирования_, 
      он стал стандартным инструментом у исследователей, которым
      необходимо описывать или рассуждать о сложных языковых конструкциях.
      Coq был использован для проверки безопасности платформы
      JavaCard, и для формальной спецификации набора инструкций x86, LLVM 
      а также языков программирования, таких как C.

    - Как _среда для разработки формально сертифицированного программного
      обеспечения_, Coq использовался для построения
      полностью верифицированного оптимизирующего компилятора для 
      C - CompCert, для доказательства корректности алгоритмов
      использующих числа с переменной точкой, а также как основа для 
      CertiCrypt, среды для вывода свойств безопасности криптографических
      алгоритмов.

    - Как _реалистичная среда для функционального программирования
      с зависимыми типами_, он послужил вдохновением для многочисленных
      иноваций, как гарвардский проект Ynot, вложивший "реляционную систему
      вывода Хоара" (расширение _Логики Хоара_ которую мы увидем в этом
      курсе) в Coq.

    - Как _помощник доказательств для логики высшего порядка_, он помог
      показать правильность серии важных результатов в математике.
      Например, его способность включать сложные вычисления внутри
      доказательств позволили разработать первое формально верифицированное
      доказательство теоремы о четырех красках. Доказательство данной
      теоремы оставалось до этого спорным среди математиков, так как
      часть его включало проверку большого числа конгифураций с помощью
      программы. В его Coq формализации все проверено, включая корректность
      вычислительной части. Недавно, еще большиие усилия привели к
      к формализации в Coq теоремы Feit-Thompson -- первого большого
      шага в классификации простых конечных групп.

   Кстати, если вам интересно почему Coq так называется, то вот что
   написано на оффициальной страничке: "Некоторые французкие ученые 
   информатики имеют традицию называть свое программное обеспечение
   видами животных: Caml, Elan, Foc и Phox примеры следования данной
   конвенции. На французком 'coq' значит петух и звучит как инициалы
   Исчисления Конструкций (Calculus of Constructions (CoC)), на 
   котором он основан."  Петух также является национальным символом
   Франции, а C-o-q are первыми тремя буквами в фамилии Thierry Coquand,
   одного из ранних его разработчиков. *)

(** ** Функциональное программирование *)

(** Термин _фунцкиональное программирование_ относится как к коллекции
    идиом программирования которые могут быть использованы в практически
    любом языке программирования, так и к семейству языков спланированых
    так чтобы подчеркивать данные идиомы, таких как Haskell, OCaml, Standard ML,
    F##, Scala, Scheme, Racket, Common Lisp, Clojure, Erlang, и Coq.

    Функциональное программирование развивалось в течении многих
    десятилетий -- действительно, его корни уходят к лямбда исчислению
    Черча, придуманому еще в 1930х, когда компьютеры еще не
    существовали! Однако с начала '90s оно вызвало всплеск интереса
    среди индустриальных инженеров и дизайнеров языков программирования,
    играющих ключевые роли в ценных проектах таких компаний как Jane St. Capital,
    Microsoft, Facebook, и Ericsson.

    Базовый догмат функционального программирования состоит в том, что
    вычисления должны быть _чистыми_ насколько это возможно. А именно,
    единственным эффектом от выполнения должен быть результат вычисления:
    вычисление должно быть свободным от _побочных эффектов_ таких как I/O, 
    присваивание значений изменяемым переменным, перенаправления указателей
    и т.д. Например, в то время как _императивная_ сортирующая функция может
    принять список чисел и перераспределить указатели чисел для того чтобы расположить
    список в нужном порядке, чистая сортирующая функция принимает изначальный 
    список и возвращает _новый_ список, содержащий теже числа в нужном порядке.

    Одна значительная выгода от такого стиля программирования состоит
    в том, что это делает более легким понимание програм и вывод их
    свойств. Когда каждая операция на структуре данных производит
    новую структуру данных, оставляя старую неизменной, то нет необходимости
    беспокоиться о том как данная структура поделена и может ли изменение
    в одной части программы нарушит инвариант на который расчитывает
    некотороя другая часть. Данные соображения особенно критичны для
    конкурентных программ, где каждая часть изменяемого состояния поделенного
    между потоками является потенциальным источником опасных багов.
    Действительно, большая часть недавнего интереса к функциональному
    программированию в индустрии связана с более простым поведением
    в случае конкурентности.

    Другая причина текущего внимания к функциональному программированию
    связана с предыдущей: функциональные программы часто легче параллелить
    чем их императивные аналоги. Если вычисление не имеет никаких
    эффектов кроме произведенного результата, тогда не важно _где_
    оно происходит. Схожим образом, если структура данных никогда не
    изменяется деструктивно, тогда она может быть свободно скопирована
    между ядрами или по сети. Действительно, идиома "Map-Reduce", которая
    лежит в основе распределенных обработчиков запросов таких как Hadoop и используемая
    Google для индексации всего веба, есть классический пример функционального
    программирования.

    Для данного курса, функциональное программирование имеет еще
    одну важную привлекательную сторону. Оно служит мостом
    между логикой и информатикой. Действительно, Coq сам по себе
    может быть рассмотрен как комбинация маленького, но очень экспрессинвного
    функционального языка программирование вместе с набором инструментов
    для выражения и доказательства логических утверждений, Более того,
    когда мы рассморим эту связь более внимательно, мы обнаружим, что
    эти две стороны Coq являются на самом деле разными аспектами одного
    и того же механизма -- т.е., _доказательства есть программы_.  *)

(** ** Верификация Программ *)

(** Почти вся первая треть книги посвященна разработке концептуального
    фреймворка логики и функционального программирования, а также
    приобретению достаточных познаний в Coq чтобы использовать его в
    выводе нетривиальных артифактов. С этого момента мы будем обращать
    свое внимание на две широкие и критически важные области в построении
    надежного программного обеспечения: техники доказательств конкретных
    свойств конкретных _програм_ и доказательство общих свойств целых
    _языков_ программирования.

    Для обоих типов доказательств нам прежде всего нужно будет
    выразить программы в виде математических объектов, чтобы можно
    было делать о них точные рассуждения. Также необходимо уметь
    описывать эти математические объекты в терминах математических 
    функций или отношений. Нашими инструментами в данной задаче
    будут _абстрактный синтаксис_ и _операционная семантика_, метод
    задающий языки программирования с помощью написания абстрактных
    интерпретаторов. Вначале мы будем работать с операционной семантикой
    в так называемом стиле "большого шага", который приводит к более
    простым и читаемым определениям, если вообще применим.
    В дальнейшем мы перейдем к чуть более детальному стилю "малого шага",
    который позволяет сделать полезные различия между разными видами
    поведения "незавершающихся" программ и применим к более широкому
    спектру языковых свойств, включая конкурентность.

    Первый язык программирования который мы рассмотрим детально _Imp_,
    является маленьким игрушечным языком охватывающим основные черты
    свойственные стандартному императивному программированию: переменные,
    присвоения, условные переходы и циклы. Мы изучим два разных способа
    рассуждения о свойствах программ на Imp.

    Во первых. ,ы рассмотрим что значит что две проргаммы на Imp 
    _эквивалентны_ в том интуитивном смысле, что они демонстируют
    тоже поведение когда запущены  на любом начальном состоянии
    памяти. Данное понятие эквивалентности затем становится критерием
    для определения корректности _метапрограмм_ -- программ которые
    манипулируют другими программами, таких каккомпиляторы и оптимизаторы.
    Мы построим простой оптимизатор для Imp и докажем его корректность.

    Во вторых, мы разработаем методологию для доказательства того,
    что заданная программа на Imp удовлетворяет формальным спецификация,
    описывающим ее поведение. Мы вводим понятие _троек Хоараs_ -- программ
    на Imp аннотированных пре- и пост-условиями описывающими что должно быть
    справедливо о памяти перед запуском и что обещано быть справедливым
    для памяти в которой они завершаются -- а также принципы вывоа _Логики Хоара_, 
    "область-специфической логики" специализированной для удобного композиционного
    вывода свойств императивных программ, с встроенными механизмами наподобие
    "инвариантов цикла".

    Данная часть курса предназначена для того, чтобы предоставить читателям
    познакомиться с ключевыми математическими идеями и инструментами широко
    используемыми в реальной верификации программного обеспечения и железа.
. *)

(** ** Системы типов *)

(** Наша заключительная большая тема, покрывающая приблизительно последнюю
    треть курса это _системы типов_, мощный набор инструментов для установления
    свойств _всех_ программ в для заданного языка.

    Системы типов наиболее признаный и популярный пример очень успешного
    класса техник формальной верификации известных как _легковесные формальные
    методы_. Это системы вывода сравнительно небольшой мощности -- достаточно
    небольшой, чтобы автоматические проверяльщики могли бы быть встроены
    в компиляторы и линкеры, или анализаторы програм и таким образом были
    бы применимы даже программистами не знакомыми с теориями лежащими в их
    основе. Другими примерами легковесных методов служат проверяльщики моделей
    железа и программного обеспечения, проверяльщики контрактов и техники
    мониторящие свойства во время рантайма для детектирования случаев
    когда компненты программ ведут себя не в соответствии со спецификацией.

    Данная тема замыкает круг. Свойства языка, что мы изучаем в данной части.
    ,а именно _лямбда исчисление с простыми типами_, есть в своей основе упрощенная
    модель ядра Coq!

*)

(* ###################################################################### *)
(** ** Литература для дальнейшего чтения *)

(** Данный текст задуман как самостоятельный и независимык. Читатели, которые
    хотели бы более глубокого изложения отдельных тем могут найти наши 
    предложения для дальнейшего чтения в главе [Postscript]. *)

(* ###################################################################### *)
(** * Практические моменты *)

(** ** Зависимость глав *)

(** Диаграмма зависимостей между главами и различные возможные 
    пути прочтения материалал могут быть найдены в файле [deps.html]. *)

(** ** Системные требования *)

(** Coq работает на Windows, Linux, и OS X.  Вам понадобится:

       - Текущий дистрибутив Coq, доступный с домашней страницы Coq.
         Все должно работать с версией 8.4.  (Версия 8.5
         может _не_ работать, из за ряда несовместимых изменений в Coq
         между версиями 8.4 и 8.5.)

       - О IDE для взаимодействия с Coq.  На данный момент есть два варианта:

           - Proof General основанная на Emacs IDE. Она обычно
             популярна среди пользователей, которым комфортно с.
             Требует отдельной установки (гуглите
             "Proof General").

           - CoqIDE более простая самостаятельная IDE. Она распространяется
             вместе с Coq, поэтому должна "просто работать" как только Coq
             установлен. Она также может быть скомпилирована из исходника,
             но на некоторых платформах это потребует инсталляции дополнительных
             зависимостей для GUI библиотек. *)

(** ** Упражениня *)

(** Каждая глава включает упражения. Каждое упражение отмечено звездочками
    что можно интерпретировать как:

       - Одна звездочка: легкие упражнения, которые подчеркивают отдельные
         моменты в тексте и для большинства читателей должны занять
         минуту или две. Приобретите привычку выполнять их сразу как 
         только встретите.

       - Две звездочки: простые упражнения (пять или десять минут).

       - Три звездочки: упражения требующие немного подумать (от дестяи минут
         до получаса).

       - Четыре или пять звездочек: более сложные упражнения (полчаса и более).

    Также некоторые упражнения отмечены как "продвинутые", а некоторые
    как "дополнительные". Практика с лишь основными и непродвинутыми
    упражнениями должно предоставить хорошее понимание материала.
    Дополнительные упражнения предоставляют возможности для большей
    практики основым идей и представляют вторичные темы, которые
    могут быь интересны отдельным читателям. Продвинутые упражнения
    добавлены для читателей, что хотят большее сложных задач.

    _Пожалуйста не постите своих решений в доступных местах_: 
    Software Foundations активно используется для самообразования и
    университетских курсов. Присутствие решений делает материал
    гораздо менее полезным для курсов, которые имеют оцениваемую
    домашнюю работу. Авторы особенно просят читателй не постить
    решений в любом месте где они могут быть найдены поисковиками.
*)

(** ** Downloading the Coq Files *)

(** A tar file containing the full sources for the "release version"
    of these notes (as a collection of Coq scripts and HTML files) is
    available here:

        http://www.cis.upenn.edu/~bcpierce/sf

    If you are using the notes as part of a class, you may be given
    access to a locally extended version of the files, which you
    should use instead of the release version.
*)

(* ###################################################################### *)
(** * Note for Instructors *)

(** If you intend to use these materials in your own course, you will
    undoubtedly find things you'd like to change, improve, or add.
    Your contributions are welcome!

    To keep the legalities of the situation clean and to have a single
    point of responsibility in case the need should ever arise to
    adjust the license terms, sublicense, etc., we ask all
    contributors (i.e., everyone with access to the developers'
    repository) to assign copyright in their contributions to the
    appropriate "author of record," as follows:

        I hereby assign copyright in my past and future contributions
        to the Software Foundations project to the Author of Record of
        each volume or component, to be licensed under the same terms
        as the rest of Software Foundations.  I understand that, at
        present, the Authors of Record are as follows: For Volumes 1
        and 2, known until 2016 as "Software Foundations" and from
        2016 as (respectively) "Logical Foundations" and "Programming
        Foundations," the Author of Record is Benjamin Pierce.  For
        Volume 3, "Verified Functional Algorithms", the Author of
        Record is Andrew W. Appel. For components outside of
        designated Volumes (e.g., typesetting and grading tools and
        other software infrastructure), the Author of Record is
        Benjamin Pierce.

    To get started, please send an email to Benjamin Pierce, describing
    yourself and how you plan to use the materials and including 
       (1) the above copyright transfer text and 
       (2) the result of doing "htpasswd -s -n NAME"
    where NAME is your preferred user name.

    We'll set you up with access to the subversion repository and 
    developers' mailing lists.  In the repository you'll find a 
    file [INSTRUCTORS] with further instructions.

*)

(* ###################################################################### *)
(** * Translations *)

(** Thanks to the efforts of a team of volunteer translators,
    _Software Foundations_ can now be enjoyed in Japanese at
    [http://proofcafe.org/sf].  A Chinese translation is underway.
*)

(** $Date: 2016-05-26 17:51:14 -0400 (Thu, 26 May 2016) $ *)
