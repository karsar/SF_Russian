(** * Rel: Свойства Отношений *)

(** Данная которкая (и дополнительная) глава разрабатывает некоторые базовые
    определения и несколько теорем о бинарных отношениях в Coq. Ключевые
    определения повторены там где они на самом деле исполъзуются (в главе
    [Smallstep]), так что читатели которым комфортно с этими идеями
    могут спокойно пройтись поверхностно или пропустить данную главу.
    Тем не менее, отношения являются хорошим источником упражнениев
    для развития навыков использования Coq', так что может быть
    полезным взглянуть на этот материал сразу после главы [IndProp]. *)

Require Export IndProp.

(** Бинарное _отношение_ на множестве [X] есть семейство пропозиций
    параметризированное двумя элементами из [X] -- т.е., пропозиция о
    парах элементов [X].  *)

Definition relation (X: Type) := X -> X -> Prop.

(** Создавая путаницу, стандартная библиотека Coq использует общий термин
    "отношение" для данной конкретной инстанциации идеи. Для того чтобы
    соответствовать библиотеке, мы быдем делать тожде самое. Таким образом,
    идентификатор Coq [relation] всегда относится к бинарному отношению
    между некоторым множеством и самим собой, в то время как русское
    слобо "отношение" может относитъся как ко специфической концепции
    Coq или более общей идеи отношения между любым числом возможно
    разных множеств. Контекст дискуссии всегда будет достаточно ясен,
    чтобы понять что мы имеем ввиду. *)

(** Примером отношения на [nat] служит [le], отношение меньше либо равно,
    которое обычно записывается как [n1 <= n2]. *)

Print le.
(* ====> Inductive le (n : nat) : nat -> Prop :=
             le_n : n <= n
           | le_S : forall m : nat, n <= m -> n <= S m *)
Check le : nat -> nat -> Prop.
Check le : relation nat.
(** (Почему мы это записываем таким способом вместо того чтобы начать с [Inductive
    le : relation nat...]?  Потому что мы хотим поставить сначало [nat]
    слево от [:], что производит слегка более удобный принцип индукции
    для вывода свойств включающих [<=].) *)

(* ################################################################# *)
(** * Основные Свойства *)

(** Как знает каждый кто брал курс дискретной математики, есть много
    что можно сказать об отношениях в целом, включая способы классификации
    отношений (как рефклексивные, транзитивные и т.д.), теоремы что могут
    быть доказаны для определенных классов отношений, конструкции
    которые строят из одних отношений другие, и т.д. Например... *)

(* ----------------------------------------------------------------- *)
(** *** Частичные Функции *)

(** Отношение [R] на множестве [X] есть _частичная функция_ если, для
    любых [x], существует только один [y] такой что [R x y] -- т.е., [R x y1]
    и [R x y2] вместе означают [y1 = y2]. *)

Definition partial_function {X: Type} (R: relation X) :=
  forall x y1 y2 : X, R x y1 -> R x y2 -> y1 = y2.

(** Например, отношение [next_nat] определенное ранее есть частичная функция. *)

Print next_nat.
(* ====> Inductive next_nat (n : nat) : nat -> Prop :=
           nn : next_nat n (S n) *)
Check next_nat : relation nat.

Theorem next_nat_partial_function :
   partial_function next_nat.
Proof.
  unfold partial_function.
  intros x y1 y2 H1 H2.
  inversion H1. inversion H2.
  reflexivity.  Qed.

(** Тем не менее, отношение [<=] на числах не является частичной функцией.
    (Предположим для противоречия, что [<=] есть частичная функция.
    Но тогда из [0 <= 0] и [0 <= 1], следует что [0 = 1]. Это бессмыслица,
    таким образом наше предположение противоречиво.) *)

Theorem le_not_a_partial_function :
  ~ (partial_function le).
Proof.
  unfold not. unfold partial_function. intros Hc.
  assert (0 = 1) as Nonsense. { 
    apply Hc with (x := 0).
    - apply le_n.
    - apply le_S. apply le_n. }
  inversion Nonsense.   Qed.

(** **** Упражнение: 2 звездочки, дополнительное  *)
(** Покажите, что [total_relation] определенное ранее есть частичная функция. *)

(* ЗАПОЛНИТЕ ЗДЕСЬ *)
(** [] *)

(** **** Упражнение: 2 звездочки, дополнительное  *)
(** Покажите, что [empty_relation] определенное ранее есть частичная функция. *)

(* ЗАПОЛНИТЕ ЗДЕСЬ *)
(** [] *)

(* ----------------------------------------------------------------- *)
(** *** Рефлексивные Отношения *)

(** _Рефлексивное_ отношение на множестве [X] это такое отношение, в котором
    каждый элемент из [X] отнесен к себе самому. *)

Definition reflexive {X: Type} (R: relation X) :=
  forall a : X, R a a.

Theorem le_reflexive :
  reflexive le.
Proof.
  unfold reflexive. intros n. apply le_n.  Qed.

(* ----------------------------------------------------------------- *)
(** *** Транзитивные Отношения *)

(** Отношение [R] _транзитивно_ если [R a c] справедливо всегда, когда имеют место [R a b]
    и [R b c]. *)

Definition transitive {X: Type} (R: relation X) :=
  forall a b c : X, (R a b) -> (R b c) -> (R a c).

Theorem le_trans :
  transitive le.
Proof.
  intros n m o Hnm Hmo.
  induction Hmo.
  - (* le_n *) apply Hnm.
  - (* le_S *) apply le_S. apply IHHmo.  Qed.

Theorem lt_trans:
  transitive lt.
Proof.
  unfold lt. unfold transitive.
  intros n m o Hnm Hmo.
  apply le_S in Hnm.
  apply le_trans with (a := (S n)) (b := (S m)) (c := o).
  apply Hnm.
  apply Hmo. Qed.

(** **** Упражнение: 2 звездочки, дополнительное  *)
(** Мы также можем доказать [lt_trans] более объемно с помощью индукции,
    без использования [le_trans].  Сделайте это.*)

Theorem lt_trans' :
  transitive lt.
Proof.
  (* Докажите индукцией по свидетельству что [m] меньше либо равно [o]. *)
  unfold lt. unfold transitive.
  intros n m o Hnm Hmo.
  induction Hmo as [| m' Hm'o].
    (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** **** Упражнение: 2 звездочки, дополнительное  *)
(** Докажите тоже самое индукцией по [o]. *)

Theorem lt_trans'' :
  transitive lt.
Proof.
  unfold lt. unfold transitive.
  intros n m o Hnm Hmo.
  induction o as [| o'].
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** Транзитивность [le], в свою очередь, может быть использована для доказательства
    некоторых полезных в будущем фактов (например, для доказательства антисимметричности
    внизу)... *)

Theorem le_Sn_le : forall n m, S n <= m -> n <= m.
Proof.
  intros n m H. apply le_trans with (S n).
  - apply le_S. apply le_n.
  - apply H.
Qed.

(** **** Упражнение: 1 звездочка, дополнительное  *)
Theorem le_S_n : forall n m,
  (S n <= S m) -> (n <= m).
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** **** Упражнение: 2 звездочки, дополнительное (le_Sn_n_inf)  *)
(** Предоставьте неформальное доказательство следующей теоремы:

    Теорема: Для каждого [n], [~ (S n <= n)]

    Формальное доказательство этого факта служит дополнительным 
    упражнением внизу, но попробуйте сначала записать его
    неформальное доказательство.

    Доказательство:
    (* ЗАПОЛНИТЕ ЗДЕСЬ *)
    []
 *)

(** **** Упражнение: 1 звездочка, дополнительное  *)
Theorem le_Sn_n : forall n,
  ~ (S n <= n).
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** Рефлексивность и транзитивность являются основными концептами
    которые нам понадобятся для следующих частей, но, для небольшой
    дополнительной практики с отношениями в Coq, давайте рассмотрим
    несколько общих свойств... *)

(* ----------------------------------------------------------------- *)
(** *** Симметричные и Антисиммитричные Отношения *)

(** Отношение [R] _симметрично_ если [R a b] означает [R b a]. *)

Definition symmetric {X: Type} (R: relation X) :=
  forall a b : X, (R a b) -> (R b a).

(** **** Упражнение: 2 звездочки, дополнительное  *)
Theorem le_not_symmetric :
  ~ (symmetric le).
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** Отношение [R] _антисимметрично_ если [R a b] и [R b a] вместе означают
    что [a = b] -- т.е., если единственные "циклы" в [R] тривиальны. *)

Definition antisymmetric {X: Type} (R: relation X) :=
  forall a b : X, (R a b) -> (R b a) -> a = b.

(** **** Упражнение: 2 звездочки, дополнительное  *)
Theorem le_antisymmetric :
  antisymmetric le.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** **** Упражнение: 2 звездочки, дополнительное  *)
Theorem le_step : forall n m p,
  n < m ->
  m <= S p ->
  n <= p.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(* ----------------------------------------------------------------- *)
(** *** Отношения Эквивалентности *)

(** Отношение является _эквивалентностью_ если оно рефлексивно, симметрично и
    транзитивно.  *)

Definition equivalence {X:Type} (R: relation X) :=
  (reflexive R) /\ (symmetric R) /\ (transitive R).

(* ----------------------------------------------------------------- *)
(** *** Частичный Порядок и Предпорядок *)

(** Отношение является _частичным порядком_ когда оно рефлексивно,
    _анти_-симметрично, и транзитивно. В стандартной библиотеке Coq
    он называется просто "порядком" для краткости. *)

Definition order {X:Type} (R: relation X) :=
  (reflexive R) /\ (antisymmetric R) /\ (transitive R).

(** Предпорядок почти такой же как частичный порядок, но не обязан
    быть антисимметричным. *)

Definition preorder {X:Type} (R: relation X) :=
  (reflexive R) /\ (transitive R).

Theorem le_order :
  order le.
Proof.
  unfold order. split.
    - (* refl *) apply le_reflexive.
    - split.
      + (* antisym *) apply le_antisymmetric.
      + (* transitive. *) apply le_trans.  Qed.

(* ################################################################# *)
(** * Рефлексивное, Транзитивное Замыкание *)

(** _Рефлексивное, транзитивное замыкание_ отношения [R] есть наименьшое
    отношение которое содержит [R] и такое что оно как рефлексивно, так
    и транзитивно.  Формально, оно определено следующим образом
    в модуле Relations стандартной библиотеки Coq: *)

Inductive clos_refl_trans {A: Type} (R: relation A) : relation A :=
    | rt_step : forall x y, R x y -> clos_refl_trans R x y
    | rt_refl : forall x, clos_refl_trans R x x
    | rt_trans : forall x y z,
          clos_refl_trans R x y ->
          clos_refl_trans R y z ->
          clos_refl_trans R x z.

(** Например, рефлексивное и транзитивное замыкание отношения
    [next_nat] совпадает с отношением [le]. *)

Theorem next_nat_closure_is_le : forall n m,
  (n <= m) <-> ((clos_refl_trans next_nat) n m).
Proof.
  intros n m. split.
  - (* -> *)
    intro H. induction H.
    + (* le_n *) apply rt_refl.
    + (* le_S *)
      apply rt_trans with m. apply IHle. apply rt_step.
      apply nn.
  - (* <- *)
    intro H. induction H.
    + (* rt_step *) inversion H. apply le_S. apply le_n.
    + (* rt_refl *) apply le_n.
    + (* rt_trans *)
      apply le_trans with y.
      apply IHclos_refl_trans1.
      apply IHclos_refl_trans2. Qed.

(** Приведенное определение рефлексивного и транзитивного замыкания естественно:
    оно говорит напрямую что рефлексивное и транзитивное замыкание
    [R] есть наименьшее отношение включающее [R] и замкнутое относительно
    правил рефлексивности и транзитивности. Но оказывается что данное
    "недетерминизм" правила [rt_trans] может иногда приводить к
    непростым индукциям. Вот более полезное определение: *)

Inductive clos_refl_trans_1n {A : Type}
                             (R : relation A) (x : A)
                             : A -> Prop :=
  | rt1n_refl : clos_refl_trans_1n R x x
  | rt1n_trans (y z : A) :
      R x y -> clos_refl_trans_1n R y z ->
      clos_refl_trans_1n R x z.

(** Наше новое определение рефлексивного и транзитивного замыкания 
    "упаковывает" правила [rt_step] и [rt_trans] в один шаг.
    Левая предпоссылка этого шага использует [R] один раз,
    приводя к более простому принципу индукции.

    Прежде чем продолжить далее, мы должны проверить что эти два определения
    действительно определяют одно и тоже отношение...

    Во первых, мы доказываем две леммы, показывая что [clos_refl_trans_1n] 
    ведет себя также как два "пропавших" конструктора [clos_refl_trans].  *)

Lemma rsc_R : forall (X:Type) (R:relation X) (x y : X),
       R x y -> clos_refl_trans_1n R x y.
Proof.
  intros X R x y H.
  apply rt1n_trans with y. apply H. apply rt1n_refl.   Qed.

(** **** Упражнение: 2 звездочки, дополнительное (rsc_trans)  *)
Lemma rsc_trans :
  forall (X:Type) (R: relation X) (x y z : X),
      clos_refl_trans_1n R x y  ->
      clos_refl_trans_1n R y z ->
      clos_refl_trans_1n R x z.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** Затем мы используем эти факты для того чтобы доказать что
    оба определения рефлексивного, транзитивного замыкания
    действительно определяют одно отношение. *)

(** **** Упражнение: 3 звездочки, дополнительное (rtc_rsc_coincide)  *)
Theorem rtc_rsc_coincide :
         forall (X:Type) (R: relation X) (x y : X),
  clos_refl_trans R x y <-> clos_refl_trans_1n R x y.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** $Date: 2016-05-26 16:17:19 -0400 (Thu, 26 May 2016) $ *)
