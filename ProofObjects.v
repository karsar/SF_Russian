(** * ProofObjects (Объекты-Доказательства): Соответствие Curry-Howard *)

(** "_Алгоритмы это вычислитльное содержание доказательств_."  --Robert Harper *)

Require Export IndProp.

(** Мы видели, Coq механизмы для _программировния_, используящие
    индуктивные типы данных вроде [nat] или [list] и функций над этими
    типами, а для _доказательства_ свойств этих программ, использования
    индуктивных пропозиции (вроде [ev]), импликации, кванторов универсальности
    , и другие. До сих пор, мы в основном использовали эти механизмы
    так будто они довольно различны, и для многих целей это хороший
    способ смотреть на вещи. Но мы также видели признаки того, что
    программирование и доказательство в Coq тесно связаны.
    Например, ключевое слово [Inductive] было использовано как для
    декларирования типов, так и пропозиций. [->] используется как
    для описания типа функций на данных, так и логическую импликацию.
    Это не просто синтаксическое совпадение! На самом деле, программы
    и доказательства в Coq практически одно и тоже. В этой главе
    мы изучим как это работает.

    Мы уже увидели фундаментальную идею: доказуемость в Coq 
    представляется через конкретное _свидетельство_.  Когда
    мы строим доказательство базовой пропозиции, мы на самом деле
    строим дерево свидетельства, которое может быть рассмотренно
    как структура данных.

    Если пропозиция есть импликация вроде [A -> B], тогда его доказательством
    будет _трансформер_ свидетельств: рецепт для конвертации свидетельства
    A в свидетельство для B. Таким образом, на фундаментальном уровне,
    доказательства это просто программы для манипулирования свидетельствами. *)

(** Вопрос: Если свидетельство есть данные, чем тогда являются сами пропозиции?

    Ответы: Они являются типами!

    Взгляните снова на формальное определение свойства [ev].  *)

Print ev.
(* ==>
  Inductive ev : nat -> Prop :=
    | ev_0 : ev 0
    | ev_SS : forall n, ev n -> ev (S (S n)).
*)

(** Предположим, что мы ввели альтернативное произношение для "[:]".
    Вместо "имеет тип", мы говорим "есть доказательство для". Например,
    вторая строчка в определении [ev] декларирует что [ev_0 : ev
    0].  Вместо "[ev_0] имеет тип [ev 0]," мы можем сказать что "[ev_0]
    есть доказательство для [ev 0]." *)

(** Такое отношение между типами и пропозициями -- [:] как "имеет тип"
    и [:] как "доказательство для" или "свидетельство для" -- называется
    _соответствием Curry-Howard_. Оно предлагает глубокую связь
    между миром логики и миром вычислений:

                 пропозиции            ~  типы
                 доказательства        ~  значения данных

    Смотрите [Wadler 2015] для короткой истории и современной экспозиции.

    Многие полезные идеи следуют из данной связи. Для начала, она
    дает естественную интерпретацию типа для конструктора [ev_SS]: *)

Check ev_SS.
(* ===> ev_SS : forall n,
                  ev n ->
                  ev (S (S n)) *)

(** Оно может быть прочтено как "[ev_SS] есть конструктор, который
    берет два аргумента -- число [n] и свидетельство для пропозиции [ev
    n] -- а затем производит свидетельство для пропозиции [ev (S (S n))]." *)

(** Теперь давайте снова взглянем на предыдущее доказательство использующее
    [ev]. *)

Theorem ev_4 : ev 4.
Proof.
  apply ev_SS. apply ev_SS. apply ev_0. Qed.

(** Как и в случае обычных значений данных и функций, мы можем использовать
    команду [Print] для того чтобы увидеть _объект доказательство_ получаемый
    из данного скрипта доказательства. *)

Print ev_4.
(* ===> ev_4 = ev_SS 2 (ev_SS 0 ev_0)
     : ev 4  *)

(** Более того, мы также можем записать данный объект доказательства
    _напрямую_, без необходимости для отдельного скрипта докозательства: *)

Check (ev_SS 2 (ev_SS 0 ev_0)).
(* ===> ev 4 *)

(** Выраэение [ev_SS 2 (ev_SS 0 ev_0)] может быть рассмотренно как
    инстанциация параметризованного конструктора [ev_SS] со специфическими
    аргументами [2] и [0] плюс соответствующими объектами доказательств
    для предпосылок [ev 2] и [ev 0].  Альтернативно, мы можем думать
    о [ev_SS] как о примитивном "конструкторе свидетельств", который
    будучи применен к заданному числу, хочет в дальнейшем быть применен
    к свидетельству того, что данное число четно; его тип,

      forall n, ev n -> ev (S (S n)),

    выражает эту функциональнсть, таким же способом полиморфный тип
    [forall X, list X] выражает факт того, что конструктор
    [nil] может быть задуман как функция из типов в пустые списки
    с элементами этих типов. *)

(** Вы можете вспомнить (как было показано в главе [Logic]) что можно
    использовать синтаксис применения функции для инстанциации
    переменных за кванторами всеобщности в леммах, а также предоставлять
    свидетельство для тех предположений, что леммы требуют. Например: *)

Theorem ev_4': ev 4.
Proof.
  apply (ev_SS 2 (ev_SS 0 ev_0)).
Qed.

(** Мы теперь можем увидеть, что данное свойство есть тривиальное
    следствия статуса который Coq предоставляют доказательствам и пропозициям:
    Леммы и гипотезы могут быть объединены в выражениях (т.е.
    объекты доказательств) следуя тем же основным правилам что
    используются для программ. *)

(* ################################################################# *)
(** * Скрипты Доказательств *)

(** _Объекты доказательств_ которые мы обсуждали лежат в основе
    того как работает Coq. Когда Coq следует скрипту доказательства, 
    внутри него последовательно строится объект доказательства -- терм
    чьим типом является доказуемая пропозиция. Тактики между
    [Proof] и [Qed] указывают как построить терм требуемого типа. Чтобы 
    увидеть данный процесс в действии, используем команду
    [Show Proof] для демонстрации текущего состояния дерева
    доказательства в различных точках следующего доказательства
    тактиками. *)

Theorem ev_4'' : ev 4.
Proof.
  Show Proof.
  apply ev_SS.
  Show Proof.
  apply ev_SS.
  Show Proof.
  apply ev_0.
  Show Proof.
Qed.

(** В каждый заданный момент, Coq построил терм с некоторыми
    "пропусками" (указанымми с помощью [?1], [?2], и так далее), и он знает
    какой тип свидетельства требуется для каждого пропуска.  *)

(** Каждый из пропусков соответствует подцели, и доказательство завершенно
    когда больше нет подцелей. В этой точке, свидетельство, что мы
    построили, хранится в глобальном контексте под именем заданным
    командой [Theorem]. *)

(** Доказательство тактиками полезно и удобно, но оно не обязательно:
    в принципе, мы всегда можем построить требуемое свидетельство
    руками, как показано сверху. Затем мы можем использовать [Definition]
    (вместо [Theorem]) для задания глобального имени напрямую для
    построенного свидетельства. *)

Definition ev_4''' : ev 4 :=
  ev_SS 2 (ev_SS 0 ev_0).

(** Все эти различные пути построения доказательств приводят точно к 
    тем же самым свидетельствам сохраненным в глобальном окружении. *)

Print ev_4.
(* ===> ev_4    =   ev_SS 2 (ev_SS 0 ev_0) : ev 4 *)
Print ev_4'.
(* ===> ev_4'   =   ev_SS 2 (ev_SS 0 ev_0) : ev 4 *)
Print ev_4''.
(* ===> ev_4''  =   ev_SS 2 (ev_SS 0 ev_0) : ev 4 *)
Print ev_4'''.
(* ===> ev_4''' =   ev_SS 2 (ev_SS 0 ev_0) : ev 4 *)

(** **** Упражнение: 1 звездочка (eight_is_even)  *)
(** Задайте доказательство тактиками, а также объект доказательства того
    что [ev 8]. *)

Theorem ev_8 : ev 8.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Definition ev_8' : ev 8 
  (* ЗАМЕНИТЕ ДАННУЮ СТРОКУ НА  := _ваше_определение_ . *) . Admitted.
(** [] *)

(* ################################################################# *)
(** * Кванторы, Импликации, Функции *)

(** В вычислительной вселенной Coq (где обитают структуры данных и программы
    ), есть два вида значений со стрелками в своих типах: _конструкторы_ вводимые
    типами определенными через [Inductive], и _функции_.

    Аналогично, в логической вселенной Coq (в которой мы производим доказательства),
    есть два способа предоставить свидетелюство для импликации:
    конструкторы введеные [Inductive]-но определенными пропозициями,
    и... функции!

    Например, рассмотрим следующее утверждение: *)

Theorem ev_plus4 : forall n, ev n -> ev (4 + n).
Proof.
  intros n H. simpl.
  apply ev_SS.
  apply ev_SS.
  apply H.
Qed.

(** Что является объектом доказательства соответствующим [ev_plus4]?

    Мы ищем выражение чьим _типом_ было бы [forall n, ev n ->
    ev (4 + n)] -- т.е., _функция_ которая берет два аргумента (одно
    число и свидететельство) и возвращает также свидетельство!
    Вот она: *)

Definition ev_plus4' : forall n, ev n -> ev (4 + n) :=
  fun (n : nat) => fun (H : ev n) =>
    ev_SS (S (S n)) (ev_SS n H).

Check ev_plus4'.
(* ===> ev_plus4' : forall n : nat, ev n -> ev (4 + n) *)

(** Вспомните что [fun n => blah] означает "функция которая, имея [n],
    производит [blah]," и Coq рассматривает [4 + n] и [S (S (S (S n)))]
    как синонимы. Другой эквивалентный способ записать данное определение: *)

Definition ev_plus4'' (n : nat) (H : ev n) : ev (4 + n) :=
  ev_SS (S (S n)) (ev_SS n H).

Check ev_plus4''.
(* ===> ev_plus4'' : forall n : nat, ev n -> ev (4 + n) *)

(** Когда мы рассматриваем пропозицию, доказуемою через [ev_plus4] кк
    тип функции, один аспект может показаться необычным. Тип
    второго аргумента, [ev n], упоминает _значение_ первого аргумента
    [n]. Хотя такие _зависимые типы_ не встречаются в обычных языках
    программирования, они также могут быть полезны в программировании,
    как это показывает последнии достижения в сообществе
    функционального программирования.

    Заметьте, что как импликация ([->]) так и кванторы всеобщности ([forall])
    соответствуют функциям на свидетельства. На самом деле, они представляют
    из себя одно и тоже: [->] есть просто сокращение для вырожденного случая
    применения [forall], когда зависимость отсутствует, т.е. нет необходимости
    предоставлять имя типу в левой стороне стрелки. *)

(** Например, рассмотрим следующую пропозицию: *)

Definition ev_plus2 : Prop :=
  forall n, forall (E : ev n), ev (n + 2).

(** Терм доказательства населяющий данную пропозицию будет функцией от
    двух аргументов: числа [n] и некоторого свидетельства [E] того, что [n]
    четно. Но имя [E] для этого свидетельства не использовано в дальнейшем
    нигде в выражении [ev_plus2], таким образом немного глупо придумывать
    ему имя. Мы могли бы вместо этого записать все следующим образом,
    используя пропуск [_] вместо настощего имени: *)

Definition ev_plus2' : Prop :=
  forall n, forall (_ : ev n), ev (n + 2).

(** Или, эквивалентно, мы можем записать его в более знакомой нотации: *)

Definition ev_plus2'' : Prop :=
  forall n, ev n -> ev (n + 2).

(** В целом, "[P -> Q]" есть просто синтаксический сахар для
    "[forall (_:P), Q]". *)

(* ################################################################# *)
(** * Связки как Индуктивные Типы *)

(** Индуктивные определения достаточно мощны чтобы выразить большинство
    связок и кванторов, что мы уже видели. Действительно, только
    квантор всеобщности (и таким образом импликация) встроенны Coq;
    все остальные определены индуктивно. Мы изучим эти определения
    в данной секции. *)

Module Props.

(** ** Конъюкция

    Чтобы доказать что [P /\ Q] справедливо, мы должны предоставить
    свидетельство как для [P], так и для [Q]. Таким образом, имеет
    смысл определить объект доказательства для [P/\ Q] как состоящего
    из пары двух доказательств: одного для [P] и другого
    для [Q]. Это приводит к следующему определению. *)

Module And.

Inductive and (P Q : Prop) : Prop :=
| conj : P -> Q -> and P Q.

End And.

(** Заметьте сходство с определением типа [prod], предоставленного
    в главе [Poly]; единственная разница лишь в том, что [prod] принимает
    [Type] аргументы, когда [and] принимает [Prop] аргументы. *)

Print prod.
(* ===>
   Inductive prod (X Y : Type) : Type :=
   | pair : X -> Y -> X * Y. *)

(** Это должно прояснить, почему мы паттерны [destruct] и [intros] могут
    быть использованы на конъюктивных гипотезах.  Анализ случаев позволяет
    нам рассмотреть все возможные пути, которыми можно доказать [P /\ Q] -- 
    здесь всего лишь один (конструктор [conj]).  Аналогично, тактика [split]
    на самом деле работает для любой индуктивно определенной пропозиции
    с только одним конструктором. В частности, она работает для [and]: *)

Lemma and_comm : forall P Q : Prop, P /\ Q <-> Q /\ P.
Proof.
  intros P Q. split.
  - intros [HP HQ]. split.
    + apply HQ.
    + apply HP.
  - intros [HP HQ]. split.
    + apply HQ.
    + apply HP.
Qed.

(** Это показывает почему индуктивное определение [and] может быть
    манипулировано тактиками как мы и делали. Мы также можем использовать
    его для построения доказательств напрямуп, используя паттерн матчинг.
    Например: *)

Definition and_comm'_aux P Q (H : P /\ Q) :=
  match H with
  | conj HP HQ => conj HQ HP
  end.

Definition and_comm' P Q : P /\ Q <-> Q /\ P :=
  conj (and_comm'_aux P Q) (and_comm'_aux Q P).

(** **** Упражнение: 2 звездочки, дополнительное (conj_fact)  *)
(** Посторйте объект доказательства демонстрирующий следующую пропозицию. *)

Definition conj_fact : forall P Q R, P /\ Q -> Q /\ R -> P /\ R 
  (* ЗАМЕНИТЕ ДАННУЮ СТРОКУ НА   := _ваше определение_ . *). Admitted.
(** [] *)

(** ** Дизъюнкция

    Индуктивное определение дизъюнкции использует два конструктора, два для
    каждой части: *)

Module Or.

Inductive or (P Q : Prop) : Prop :=
| or_introl : P -> or P Q
| or_intror : Q -> or P Q.

End Or.

(** Данная декларация объясняет поведение тактики [destruct] на
    дизъюнктивной гипотезе, так как сгенерированные подцели соответствуют
    форме конструкторов [or_introl] и [or_intror].

    Опять же, мы можем также напрямую записать объекты доказательств для
    теорем включающих [or], без обращения к тактикам. *)

(** **** Упражнение: 2 звездочки, дополнительное (or_commut'')  *)
(** Попробуйте записать явный объект доказательства для [or_commut] (без применения
   [Print] чтобы увидеть уже готовое!). *)

Definition or_comm : forall P Q, P \/ Q -> Q \/ P 
(* ЗАМЕНИТЕ ЭТУ СТРОКУ НА   := _ваше определение_ . *). Admitted.    
(** [] *)

(** ** Квантор Существования

    Для предоставления доказательства в случае квантора существования, мы
    упаковываем свидетельство [x] вместе с доказательством того что [x] удовлетворяет
    свойству [P]: *)

Module Ex.

Inductive ex {A : Type} (P : A -> Prop) : Prop :=
| ex_intro : forall x : A, P x -> ex P.

End Ex.

(** Это стоило бы немного разъяснить. Основа определения состоит в
    формирующем тип [ex] которое может быть использовано для построения
    пропозиций в форме [ex P], где [P] само по себе есть _функция_ из 
    значений свидетельства типа [A] в пропозиции. Конструктор [ex_intro]
    таким образом предоставляет способ построения доказательства для [ex P],
    имея свидетельство [x] и доказательство [P x].

    Более знакомая форма [exists x, P x] есть синтаксический сахар для
    выражения включающего [ex]: *)

Check ex (fun n => ev n).
(* ===> exists n : nat, ev n
        : Prop *)

(** Вот пример того как определять явно объект доказательства включающий [ex]: *)

Definition some_nat_is_even : exists n, ev n :=
  ex_intro ev 4 (ev_SS 2 (ev_SS 0 ev_0)).

(** **** Упражнение: 2 звездочки, дополнительное (ex_ev_Sn)  *)
(** Завершите определение следующего объекта доказательства: *)

Definition ex_ev_Sn : ex (fun n => ev (S n)) 
  (* ЗАМЕНИТЕ ДАННУЮ СТРОКУ НА   := _ваше определение_ . *). Admitted.
(** [] *)

(* ================================================================= *)
(** ** [True] и [False] *)

(** Индуктивное определение пропозиции [True] просто: *)

Inductive True : Prop :=
  I : True.

(** Оно имеет один конструктор (так что все доказательства [True] одинаковы, 
    так что иметь доказательство [True] не очень информативно.) *)

(** [False] аналогично прост -- действительно, настолько просто, что может
    показаться синктаксически неверным на первый взгляд! *)

Inductive False : Prop :=.

(** И да, [False] является индуктивным типом _без_ конструкторов --
    т.е., не существует способа построить его доказательства. *)

End Props.

(* ################################################################# *)
(** * Программирование с Тактиками *)

(** Если мы может строить доказательства преоставляя явные термы, вместо
    запуска скриптов с тактиками, то можно спросить а можем ли
    мы строить _программы_ используя _тактики_ вместо явных термов.
    Естественно, ответ положителен! *)

Definition add1 : nat -> nat.
intro n.
Show Proof.
apply S.
Show Proof.
apply n. Defined.

Print add1.
(* ==>
    add1 = fun n : nat => S n
         : nat -> nat
*)

Compute add1 2.
(* ==> 3 : nat *)

(** Заметьте, что мы завершили [Definition] используя [.] вместо
    [:=] с последующим термом. Это говорит Coq зйати в режим _скрипта
    доказательства_ для построения объекта типа [nat -> nat]. Также, мы
    завершаем доказательство с [Defined] вместо [Qed]; это делает определение
    _прозрачным_ так что оно может быть использовано в вычислениях как
    и нормально определенная функция.  ([Qed]-определенные объекты не
    прозрачны для вычислений.)

    Данное свойство в основном полезно для написания функция с
    зависимыми типами, которые мы не будем особенно затрагивать
    в данной книге. Но оно иллюстрирует всеобщность и 
    ортогональность основных идей в Coq. *)

(* ################################################################# *)
(** * Равенство *)

(** Даже отношение равенства не встроено в Coq.  Оно имеет следующее
    индуктивное определение.  (На самом деле, определение в стандарной
    библиотеке есть небольшая вариация его, котораое предоставляет
    принцип индукции слегка более удобный для применения.) *)

Module MyEquality.

Inductive eq {X:Type} : X -> X -> Prop :=
| eq_refl : forall x, eq x x.

Notation "x = y" := (eq x y)
                    (at level 70, no associativity)
                    : type_scope.

(** Способ которым нужно думать о данном определении следующий, имея множество
    [X], оно определяет _семейство_ пропозиций "[x] равно [y]," индексированных
    парами значений ([x] и [y]) из [X]. Существует лишь один способ
    предоставления свидетельства для каждого члена этого семейства:
    применяя конструктор [eq_refl] к типу [X] и значению [x :
    X] что производит доказательство того, что [x] равно [x]. *)

(** **** Упражнение: 2 звездочки (leibniz_equality)  *)
(** Индуктивное определение равенства соответствует _равенству по
    Лейбницу_: под "[x] и [y] равны" мы понимаем, что каждое свойство [P]
    справедливое для [x] также справедливо для
    [y].  *)

Lemma leibniz_equality : forall (X : Type) (x y: X),
  x = y -> forall P:X->Prop, P x -> P y.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *)
Admitted.
(** [] *)

(** Мы можем использовать [eq_refl] для построения доказательства что,
    например, [2 = 2]. Можем ли мы также использовать его для построения
    доказательства того что [1 + 1 = 2]? Да, мы можем. Действительно,
    это тоже самое доказательство! Причина, по которой Coq принимает тоже
    доказательство в том что он счичает "одинаковыми" любые два терма которые
    _взаимно конвертируемы_ согласно простому набору вычислительных правил.
    Эти правила, которые похожи на те что используются [Compute], включают
    вычисления применения функции, раскрытие определений, и упрощение [match]ей.  *)

Lemma four: 2 + 2 = 1 + 3.
Proof.
  apply eq_refl.
Qed.

(** Тактика [reflexivity] которая была использована для доказательства
    равенств до сих пор есть просто сокращение для [apply refl_equal].

    В доказательствах равенств основанных на тактиках, правила конвертации
    обычно скрыты в использованиях [simpl] (либо явно, либо неявно
    в других тактиках как [reflexivity]). Но бы можете увидеть их
    напрямую в работе в следующих явных объектах доказательств: *)

Definition four' : 2 + 2 = 1 + 3 :=
  eq_refl 4.

Definition singleton : forall (X:Set) (x:X), []++[x] = x::[]  :=
  fun (X:Set) (x:X) => eq_refl [x].


End MyEquality.

Definition quiz6 : exists x,  x + 3 = 4
  := ex_intro (fun z => (z + 3 = 4)) 1 (refl_equal 4).

(* ================================================================= *)
(** ** Инверсия, Снова *)

(** Мы видели применение [inversion] как в случае равенства, так и в случае
    индуктивно определенных пропозиций. Теперь, когда мы увидели, что это
    теже самые вещи, мы можем более детально изучить как ведет себя [inversion].

    В целом, тактика [inversion]...

    - берет гипотезу [H] чей тип [P] индуктивно определен и

    - для каждого конструктора [C] в определении [P],

      - генерирует новую подцель, в которой предполагает что [H] было
        посторено с [C],

      - добавляет аргументы (предпосылки) для [C] в контекст подцели как
        дополнительные гипотезы,

      - сравнивает заключение (тип результата) [C] с текущей целью
        и вычисляет множество равенств которые должны иметь место
        для того чтобы [C] было применимо,

      - добавляет данные равенства в контекст (и, для удобства
        переписывает их в цели), и

      - если равенства не могут быть удовлетворены (т.е., они включают
        вещи вроде [S n = O]), сразу разрешает подцель. *)

(** _Пример_: Если мы инвертируем гипотезу построенную с помощью [or],
   то есть два конструктора, так что генерируются две подцели. Заключение
   (окончательный тип) конструктора ([P \/ Q]) не ставит никаких ограничений
   на форму [P] или [Q], так что мы не получаем дополнительных равенств
   в контексте подцелей.

   _Example_: If we invert a hypothesis built with [and], there is
   only one constructor, so only one subgoal gets generated.  Again,
   the conclusion (result type) of the constructor ([P /\ Q]) doesn't
   place any restrictions on the form of [P] or [Q], so we don't get
   any extra equalities in the context of the subgoal.  The
   constructor does have two arguments, though, and these can be seen
   in the context in the subgoal.

   _Пример_: Если мы инвертируем гипотезу постронную с [eq], то у нас
   опять всего лишь один конструктор, так что генерируется лишь одна подцель.
   Теперь, форма конструктора [refl_equal] предоставляет нам дополнительную
   информацию: она говорит нам что два аргумента [eq] должны быть одним и
   тем же!  Тактика [inversion] добавлает данный факт в контекст. *)

(** $Date: 2016-07-14 17:02:35 -0400 (Thu, 14 Jul 2016) $ *)

