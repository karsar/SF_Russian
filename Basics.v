(**` * Основы: Функциональное программирование в Coq *)

(* НАПОМИНАНИЕ:

          #######################################################
          ###  ПОЖАЛУЙСТА НЕ РАСПРОСТРАНЯЙТЕ РЕШЕНИЯ ПУБЛИЧНО ###
          #######################################################

   (Смотрите [Preface] для ответа почему.) 

*)

(* [Admitted] это способ  указать Coq что нужно принять формулировку
   без доказательства. Мы используем эту команду, чтобы отметить
   'пробелы' которуе должны быть заполнены как часть домашнего задания.
   На практике, [Admitted] полезно при инкрементальной разработке больших
   доказательств. *)
Definition admit {T: Type} : T.  Admitted.

(* ###################################################################### *)
(** * Введение *)

(** Функциональный стиль программирования делает программирование ближе
    к простой, ежедневной математике: если процедура и метод не имеют
    побочных эффектов, тогда (игнорируя эффективность) все что нам надо
    понимать, это то как входы отображаются в выходы -- т.е. мы можем
    рассуждать как о конкретном методе расчета математической фунции.
    Это один из смыслов термина "функциональный" в "функциональном
    программировании".  Прямая связь между программами и простыми
    математическими объектами поддерживает как формальные доказательства
    корректности, так и непротиворечивый неформальный вывод свойств о
    поведении программ.

    Другой смысл, в котором функциональное программированое является
    "функциональным" заключается в том, что оно подчеркивает использование
    функций (или методов) как значений _первого класса_ -- т.е., значений
    которые можно передавать как аргументы другим функциям, возвращать
    как результаты, включать в структуры данных и т.д. Понимание того
    что функции могут быть использованы как данные позволяет применять
    полезные и мощные идиомы программирования.

    Другие общие свойства функциональных языков программирования включают
    в себя _алгербраические структуры данных_ и _сопостовление с образцом_, 
    что позволяет строить и манипулировать богатые структуры данных и 
    сложные _полиморфные системы типовs_, поддерживающие абстракцию и 
    повторное использование кода. Coq поддерживает все данные свойства.

    Первая половина данной главы вводит наиболее необходимые элементы
    функционального программирования в Coq.  Вторая половина вводит основы
    некоторых базовых _тактик_ которые могут быть использованы для доказательства
    простых свойств программ в Coq. *)

(* ###################################################################### *)
(** * Перечислимые типы *)

(** Один необычный аспект Coq состоит в том, что множество встроенных в него
    элементов программирования _необычайно_ мало.  Например, вместо
    обычной палитры атомарных типов данных (булевым значение, целые числа,
    строки, и т.д.), Coq предлагает мощный механизм для определения новых
    типов данных с нуля, используя который все эти знакомые типы появляются
    как образцы.

    Безусловно, дистрибутив Coq поставляется вместе с большой стандартной
    библиотекой, предоставляющей определения булевых значений, чисел
    и многих других популярных структур данных, как списки и хэш таблицы.
    Однако в этих определениях нет ничего магического. Чтобы проиллюстрировать
    это, мы непосредственно определим все что нам нужно в данном курсе,
    вместо использования аналогов из стандартной библиотеку.

    Чтобы увидеть как работает механизм определений, начнем с очень простого
    примера. *)

(* ###################################################################### *)
(** ** Дни недели *)

(** Следующая заявление говорит Coq что мы определяем новое множество
    значений --  _тип_. (дни недели на английском языке, значения типа 
    "день" (day) *)

Inductive day : Type :=
  | monday : day
  | tuesday : day
  | wednesday : day
  | thursday : day
  | friday : day
  | saturday : day
  | sunday : day.

(** Тип имеет имя [day], и его членами являются значения [monday],
    [tuesday], и т.д. Вторая и последующие строки определения могут
    быть прочтены как "[monday] есть [day], [tuesday] есть [day],и т.д."

    Определив [day], мы можем записать функции оперирующие на днях.
    Например функцию определяющую следующий рабочий день *)

Definition next_weekday (d:day) : day :=
  match d with
  | monday    => tuesday
  | tuesday   => wednesday
  | wednesday => thursday
  | thursday  => friday
  | friday    => monday
  | saturday  => monday
  | sunday    => monday
  end.

(** Одна вещь которая заметна сразу, это то что типы аргумента и возвращаемого
    значения данной функция заданы явно. Как и во многих функциональных
    языках программирования, Coq может часто определить самостоятельно эти типы,
    тогда когда они явно не заданы -- т.е., проделывает
    _вывод типа_ -- но мы включаем явные определение, чтобы сделать чтение
    легче. *)

(** Определив функцию, мы должны проверить, что она работает на
    некоторых примерах. Существует три разных способа сделать это в Coq.

    Во первых, мы можем использовать комманду [Compute] для получения
    значения выражения включающего [next_weekday]. *)

Compute (next_weekday friday).
(* ==> monday : day *)

Compute (next_weekday (next_weekday saturday)).
(* ==> tuesday : day *)

(** (Мы демонстрируем реакцию Coq в комментариях, но, если у вас есть
     компьютер под рукой, то будет просто отличным решением запустить
    интерпретатор Coq в предпочтительным вами IDE -- либо CoqIde либо Proof
    General -- и попробовать команды самому. Загрузите этот файл, [Basics.v],
    из исходников Coq дополняющих данную книгу, найдите приведенный пример
    пошлите его Coq, и пронаблюдайте результат.)

    Во вторых, мы можем записать что именно мы _ожидаем_ как результат в виде
    примера (example) Coq: *)

Example test_next_weekday:
  (next_weekday (next_weekday saturday)) = tuesday.

(** Данная декларация делает две вещи: оно задает утверждение
    (что второй рабочий день после субботы есть вторник) и присваивает
    данному утверждению имя, по которому к нему можно будет обращаться
    в дальнейшем.

    Сделав утверждение, мы можем попросить Coq верифицировать его следующим
    образом: *)

Proof. simpl. reflexivity.  Qed.

(** Детали на данный момент не так важны (мы вернемся к ним чуть позднее),
    но в целом этот набор команд может быть прочтен как "Данное утверждение
    которое мы сейчас сделали, может быть доказано, если обратить внимание
    на то что обе стороны равенства выражают одно и тоже значение после
    некоторых упрощений.".  (simpl сокращенно от simplification - упрощение)

    В третьих, мы можем попросить Coq  _выделить_, из нашего [Definition],
    программу на некотором другом языке программирования, более привычном
    вроде OCaml, Scheme, или Haskell), который имеет эффективный компилятор.
    Данная возможность очень интересна, так как позволяет построить _полностью
    сертифицированные_ программы на мейнстримовых языках программирования.
    В действительности, это одно из основных применений, для которых Coq и был
    разработан. Мы вернемся к этой теме в последующих главах. *)

(* ###################################################################### *)
(** ** Булевы значения *)

(** Схожим образом, мы можем определить стандартный тип [bool]
    булевых значений, с членами [true] (правда) и [false] (ложь). *)

Inductive bool : Type :=
  | true : bool
  | false : bool.

(** Хотя мы вводим здесь булевы значения для того чтобы показать
    как ввести их с нуля, Coq конечно предоставляет стандартную
    реализацию булевых значений как часть своей стандартной библиотеки,
    вместе со множеством полезных функций и лемм. (Загляните в
    [Coq.Init.Datatypes] в документации библиотеки Coq, если заинтересованы.)
    Везде где возможно, мы будем именовать наши определения и теоремы так
    чтобы они точно совпадали с аналогичными из стандартной библиотеки.

    Функции на булевых значениях могут быть определены таким же
    способом, как предыдущие: *)

    (** отрицание **)
Definition negb (b:bool) : bool :=
  match b with
  | true => false
  | false => true
  end.

(** логическое и **)
Definition andb (b1:bool) (b2:bool) : bool :=
  match b1 with
  | true => b2
  | false => false
  end.

(** логическое или **)
Definition orb (b1:bool) (b2:bool) : bool :=
  match b1 with
  | true => true
  | false => b2
  end.

(** Последние две иллюстрируют синтакс Coq для случая функции нескольких
    аргументов. Соответствующий синтаксис применения функции от нескольких
    аргументов продемонстрирован с помощью следующих четырех "юнит тестов",
    которые составляют полную спецификацию -- таблицу правдивости -- функции [orb]: *)

Example test_orb1:  (orb true  false) = true.
Proof. simpl. reflexivity.  Qed.
Example test_orb2:  (orb false false) = false.
Proof. simpl. reflexivity.  Qed.
Example test_orb3:  (orb false true)  = true.
Proof. simpl. reflexivity.  Qed.
Example test_orb4:  (orb true  true)  = true.
Proof. simpl. reflexivity.  Qed.

(** Мы также можем ввести более знакомый синтаксис для булевых операций,
    которые мы только что определили. Команда [Infix] определяет новую
    инфиксную нотацию для существующего определения. *)

Infix "&&" := andb.
Infix "||" := orb.

Example test_orb5:  false || false || true = true.
Proof. simpl. reflexivity. Qed.

(** _Замечание о нотации_: В файлах [.v], мы используем квадратные скобки
    чтобы выделить фрагменты кода Coq в комментариях; такая конвенция
    также используется утилитой документации [coqdoc] и позволят держать
    фрагмены кода выделенно из всего окружающего текста. В html версии
    эти куски текста будут записаны с использованием [другого фонта].

    Специальные фразы [Admitted] и [admit] могут быть использованы как
    временные заглушки в незаконченных определениях и доказательствах.
    Мы используем их в упражнениях. чтобы указать на те части, что 
    оставлены для заполнения читателю -- это ваша работа заменять [admit] 
    или [Admitted] настоящими доказательствами и определениями. *)

(** **** Упражнение: 1 звездочка (nandb)  *)
(** Уберите [admit] и завершите определение следующей функции;
    затем запишите утверждения [Example] которые могут быть верифицированы Coq.
    (Уберите "[Admitted.]" и заполните каждое доказательство, следуя подходу
    тестов для [orb] сверху.) Функция должна возвращать [true] если один или оба
    аргумента [false]. *)

Definition nandb (b1:bool) (b2:bool) : bool :=
  (* FILL IN HERE *) admit.

Example test_nandb1:               (nandb true false) = true.
(* Заполните здесь *) Admitted.
Example test_nandb2:               (nandb false false) = true.
(* Заполните здесьFILL IN HERE *) Admitted.
Example test_nandb3:               (nandb false true) = true.
(* Заполните здесьFILL IN HERE *) Admitted.
Example test_nandb4:               (nandb true true) = false.
(* Заполните здесьFILL IN HERE *) Admitted.
(** [] *)

(** **** Упражнение: 1 звездочка (andb3)  *)
(** Сделайте тоже самое для функции [andb3] внизу. Эта функция должна
    возвращать [true] когда все три входа [true], и [false]
    в противном случае. *)

Definition andb3 (b1:bool) (b2:bool) (b3:bool) : bool :=
  (* FILL IN HERE *) admit.

Example test_andb31:                 (andb3 true true true) = true.
(* Заполните здесь *) Admitted.
Example test_andb32:                 (andb3 false true true) = false.
(* Заполните здесь *) Admitted.
Example test_andb33:                 (andb3 true false true) = false.
(* Заполните здесь *) Admitted.
Example test_andb34:                 (andb3 true true false) = false.
(* Заполните здесь *) Admitted.
(** [] *)

(* ###################################################################### *)
(** ** Типы Функций *)

(** Каждое выражение в Coq имеет тип, описывающий кого сорта вещи
    оно высчитывает. Команда [Check] просит Coq напечатать тип выражения. *)

(** Например, типом [negb true] является [bool]. *)

Check true.
(* ===> true : bool *)
Check (negb true).
(* ===> negb true : bool *)

(** Функции вроде [negb] сами являются значениями, также как
    [true] и [false].  Их типы называются _функциональными типами_, 
    и записываются с помощью стрелок. *)

Check negb.
(* ===> negb : bool -> bool *)

(** Тип [negb], записанный как [bool -> bool] и произносимый
    "[bool] стрелочка [bool]," может быть прочтен как, "Имея значения
    типа [bool], данная функция производит результат типа [bool]."
    Аналогично, тип [andb], записанный как [bool -> bool -> bool], может
    быть прочтен "Имея два входа, оба типа [bool], данная функция производит
    результат типа [bool]." *)

(* ###################################################################### *)
(** ** Модули *)

(** Coq предоставляет _систему модулей_, чтобы помочь в организации больших
    разработок. В данном курсе нам не понадобится большинство ее возможностей,
    но одно очень полезно: если мы поставим некоторый набор определений между 
    маркерами [Module X] и [End X], тогда, в оставшейся части файла после 
    [End], эти определения могут быть адресованы как [X.foo] вместо просто [foo].
    Здесь мы используем данную возможность для введения типа [nat] во внутреннем
    модуле, так чтобы он не пересекался с определением из стандартной библиотеки,
    которое поставляется с некоторой специальной нотационной магией.  *)

Module Playground1.

(* ###################################################################### *)
(** ** Числа *)

(** Типы которые мы определяли до сих пор являются примерами "перечислимых 
    типов": их определения явно перечисляют конечное множество элементов.
    Более интересным способом определения типа является предоставление
    набора _индуктивных правил_ описывающих его элементы. Например,
    мы можем определить натуральные числа следующим образом: *)

Inductive nat : Type :=
  | O : nat
  | S : nat -> nat.

(** Данное определение может быть прочтено как:
      - [O] есть натуральное число (обратите внимание, что это буква "[O],"
        а не число "[0]").
      - [S] "конструктор" который принимает натуральное число и производит
        новое -- а именно, если [n] натуральное число, то [S n] также.

    Давайте посмотрим на это более детально.

    Каждое индуктивно определенное множество ([day], [nat], [bool], etc.)
    является набором  _выражений_.  Определение [nat] указывает как
    выражения из множества  [nat] могут быть построены:

    - выражение [O] принадлежит множеству [nat];
    - если [n] есть выражение принадлежащее множеству [nat], тогда [S n]
      также принадлежит множеству [nat]; и
    - выражения построенные этими двумя путями единственные выражение
      принадлежащие множеству [nat].

    Те же правила применимы к определениям [day] и [bool].
    Аннотации которые мы использовали в случае их конструкторов
    аналогичны случаю конструктора [O], показывая что они не требуют
    аргументов.

    Данные три условия как раз и состовляют силу деклараций [Inductive].
    Они утверждают, что выражение [O], выражение
    [S O], выражение [S (S O)], выражение [S (S (S O))], и так далее
    принадлежат множеству [nat], в то время как выражения
    [true], [andb true false], и [S (S false)] нет.

    Мы можем записать простые функции которые используют сопоставление
    с образцом на натуральных числах, также как мы делали это сверху -- 
    например для функции вычисляющей предшественника (predecessor
    function): *)

Definition pred (n : nat) : nat :=
  match n with
    | O => O
    | S n' => n'
  end.

(** Вторую ветвь можно прочесть как: "если [n] имеет форму [S n']
    для некоторого [n'], тогда возвратить [n']."  *)

End Playground1.

Definition minustwo (n : nat) : nat :=
  match n with
    | O => O
    | S O => O
    | S (S n') => n'
  end.

(** Поскольку натуральные числа настолько всепроникающи и часты,
    Coq предоставляет немного встроенной магии для их парсинга и вывода:
    обычные арабские цифры могут быть использованы как альтернатива
    "унарной" нотации определенной конструкторами [S] и [O].  Coq
    печатает числа используя арабские цифры по умолчанию: *)

Check (S (S (S (S O)))).
  (* ===> 4 : nat *)
Compute (minustwo 4).
  (* ===> 2 : nat *)

(** Конструктор [S] имеет тип [nat -> nat], в точности как
    функции [minustwo] и [pred]: *)

Check S.
Check pred.
Check minustwo.

(** Все они могут быть применены к числу для получения чиска.
    Тем не менее, существует фундаментальная разница между конструктором
    и другими двумя функциями: функции вроде [pred] и [minustwo]
    поставляются вместе _правилами вычислений_ -- т.е., определение [pred]
    утверждает, что [pred 2] может быть упрощено до [1] -- в то время
    как определение [S] не имеет такого прикрепленного поведения. 
    Хотя он и как функция, в том смысле что его можно применить
    к аргументу, он _ничего_ не делает!

    Для всех определений функций на числах, просто сопоставления 
    с образцом часто недостаточно: нам нужна реккурсия. Например,
    чтобы увидеть что число [n] четно, нам будет нужно реккурсивно
    проверить четность [n-2]. Для написания таких функций мы используем
    ключевое слово [Fixpoint]. *)

Fixpoint evenb (n:nat) : bool :=
  match n with
  | O        => true
  | S O      => false
  | S (S n') => evenb n'
  end.

(** Мы можем аналогично определить [oddb] используя [Fixpoint] декларацию, 
    но воспользуемся более простым определением с которым будет слегка
    легче работать: *)

Definition oddb (n:nat) : bool   :=   negb (evenb n).

Example test_oddb1:    oddb 1 = true.
Proof. simpl. reflexivity.  Qed.
Example test_oddb2:    oddb 4 = false.
Proof. simpl. reflexivity.  Qed.

(** (Заметьте, проходитя по доказательству пошагово, что
    [simpl] на самом деле не имеет эффекта на цель -- вся работа совершается
    командой [reflexivity].  Мы скоро увидем причину почему.)

    Конечно мы можем определить и функцию нескольких аргументов, 
    используя реккурсию.  *)

Module Playground2.

Fixpoint plus (n : nat) (m : nat) : nat :=
  match n with
    | O => m
    | S n' => S (plus n' m)
  end.

(** Складывая двойку и тройку мы получитм пять, как и ожидалось. *)

Compute (plus 3 2).

(** Упрощение которое использует Coq чтобы прийти к такому результату можно
    визуализировать следующим образом: *)

(*  [plus (S (S (S O))) (S (S O))]
==> [S (plus (S (S O)) (S (S O)))]
      по второму пункту [match]
==> [S (S (plus (S O) (S (S O))))]
      по второму пункту [match]
==> [S (S (S (plus O (S (S O)))))]
      по второму пункту [match]
==> [S (S (S (S (S O))))]
      по первому пункту [match]
*)

(** Для удобства, если два или более аргументов функции имеют тот же тип,
    они могут быть записаны вместе. В следующем определении, [(n m : nat)]
    означает то же самое, что и [(n : nat) (m : nat)]. *)

Fixpoint mult (n m : nat) : nat :=
  match n with
    | O => O
    | S n' => plus m (mult n' m)
  end.

Example test_mult1: (mult 3 3) = 9.
Proof. simpl. reflexivity.  Qed.

(** Мы можете сопостовлять сразу два выражения одновременно, поставив запятую между 
    ними: *)

Fixpoint minus (n m:nat) : nat :=
  match n, m with
  | O   , _    => O
  | S _ , O    => n
  | S n', S m' => minus n' m'
  end.

(**  _ в первой линии является _постановочным шаблоном_.  Запись _ в шаблоне
    является тем же самым, что и использование какой либо переменной,
    которая не будет использована в правой части. Это освобождает нас
    от необходимости придумывать ей имя. *)

End Playground2.

Fixpoint exp (base power : nat) : nat :=
  match power with
    | O => S O
    | S p => mult base (exp base p)
  end.

(** **** Упражнение: 1 звездочка (factorial)  *)
(** Вспомним стандартную математическую функцию факториала:

       factorial(0)  =  1
       factorial(n)  =  n * factorial(n-1)     (если n>0)

    Переведите ее в Coq. *)

Fixpoint factorial (n:nat) : nat :=
(* ЗАПОЛНИТЕ ЗДЕСЬ *) admit.

Example test_factorial1:          (factorial 3) = 6.
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
Example test_factorial2:          (factorial 5) = (mult 10 12).
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** Мы можем сделать числовые выражение болеее легкими для чтения и записи
    введя _нотации_ для сложения, умножения и вычитания. *)

Notation "x + y" := (plus x y)
                       (at level 50, left associativity)
                       : nat_scope.
Notation "x - y" := (minus x y)
                       (at level 50, left associativity)
                       : nat_scope.
Notation "x * y" := (mult x y)
                       (at level 40, left associativity)
                       : nat_scope.

Check ((0 + 1) + 1).

(** (Аннотации [level], [associativity], и [nat_scope] контроллируют
    как эти нотации распознаются парсером Coq. Детали здесь не важны
    но заинтересованные читатели могут заглянуть в необязательную секцию
    "Больше о Нотациях" в конце данной главы.)

    Заметьте, что мы не помемяли определений которые уже были сделаны:
    аннотации просто инструкции парсеру Coq принять [x + y] вместо
    [plus x y] и, обратно, для вывода Coq напечатать
    [plus x y] как [x + y].

    Когда мы говорим, что Coq поставляется без чего лиго встроенного, мы
    действительно имеем это ввиду: даже проверка на равенство чисел является
    операцией определенной пользователемн! *)

(** Функция [beq_nat] тестирует [nat]уральные числа на равенство ([eq]uality),
    выдавая [b]улево значение.  Обратите внимание на использование
    вложенных сравннений [match] (мы также могли бу использовать
    одновременное сравнение, как это было сделано в определении [minus].)  *)

Fixpoint beq_nat (n m : nat) : bool :=
  match n with
  | O => match m with
         | O => true
         | S m' => false
         end
  | S n' => match m with
            | O => false
            | S m' => beq_nat n' m'
            end
  end.

(** Функция [leb] тестирует является ли первый аргумент меньше или
    равным втроому, выдавая булево значение. *)

Fixpoint leb (n m : nat) : bool :=
  match n with
  | O => true
  | S n' =>
      match m with
      | O => false
      | S m' => leb n' m'
      end
  end.

Example test_leb1:             (leb 2 2) = true.
Proof. simpl. reflexivity.  Qed.
Example test_leb2:             (leb 2 4) = true.
Proof. simpl. reflexivity.  Qed.
Example test_leb3:             (leb 4 2) = false.
Proof. simpl. reflexivity.  Qed.

(** **** Упражнение: 1 звездочка (blt_nat)  *)
(** Функция [blt_nat] тестирует [nat]уральные числа на условие меньше чем ([l]ess-[t]han),
    производя [b]улево значение.  Вместо того, чтобы придумывать новое определеное [Fixpoint]
    для нее, определите ее в терминах предыдуще определенной функции. *)

Definition blt_nat (n m : nat) : bool :=
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) admit.

Example test_blt_nat1:             (blt_nat 2 2) = false.
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
Example test_blt_nat2:             (blt_nat 2 4) = true.
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
Example test_blt_nat3:             (blt_nat 4 2) = false.
(* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(* ###################################################################### *)
	(** * Доказательство упрощением *)

(** Теперь, когда мы определили несколько типов данных и функций, давайте
    обратимся к формулированию и доказательству их свойств.
    На самом деле, мы уже начали этим заниматься: каждый [Example] из предыдущей
    секции делает конкретное заявление о поведенийй некоторой функции
    при некоторых входных данных. Доказательства этих заявлений были
    везде одинаковы: использовалась [simpl] для упрощения обеих сторон равенства,
    затем [reflexivity] для проверки того что обе части равенства содержат
    идентичные значенияж.

    Такого же типа "доказательство упрощением" может быть использовано
    также и для более интересных свойств. Например, факт того, что
    [0] является "нейтральным элементом" для [+] слева может быть доказан
    если заметить, что [0 + n] сводится к [n] независимо от значения [n],
    что ясно видно напрямую из определения [plus].*)

Theorem plus_O_n : forall n : nat, 0 + n = n.
Proof.
  intros n. simpl. reflexivity.  Qed.

(** (Вы можете заметить, что утверждение сверху выглядит иначе в
    в файле [.v] открытом в вашем IDE чем в HTML на вашем браузере,
    если сравнить оба варианта. В файлах [.v], мы записываем квантор
    универсальности [forall] используя зарезервированный индентификатор
    "forall."  Когда файлы с расширением [.v] конвертируются в, он
    трансформируется в перевернутое-A.) *)

(** Это также хороший момент, чтобы упомянуть, что [reflexivity] 
    несколько более мощная тактика, чем упомянуто. В примерах, что
    мы видели сверху, вызовы [simpl] были на самом деле не нужны, так
    как [reflexivity] может делать упрощение автоматически, проверяя
    на равенство обе стороны. [simpl] было добавлено, чтобы мы могли
    увидеть промежуточное состояние -- после упрощения, но до завершения
    доказательства. Приведем укороченный вариант доказательства: *)

Theorem plus_O_n' : forall n : nat, 0 + n = n.
Proof.
  intros n. reflexivity. Qed.

(** Более того, будет полезно знать, что [reflexivity]
    делает несколько _больше_ упрощений чем [simpl] -- например,
    она пытается "раскрыть" определенные термы, замещая их правыми
    частями определений. Причина такой разницы в том, что если
    рефлексивность срабатывает, то все цель завершена и на нет
    необходимости заглядывать в развернутые выражения созданные [reflexivity]
    за время упрощения и развертки. [simpl], в отличии от рефлексивности,
    используется в ситуациях, где нам может быть необходимо читать о
    понимать новую цель, которая создана, так что мы не хотим, чтобы
    она слепо разворачивала определения и оставляла цель в 
    замусоренном состоянии. *)

(** Форма теоремы, что мы сформулировали и ее доказательство 
    практически идентичны более простым примерам, что мы приводили
    раньше. Стоит отметить всего несколько различий.

    Во первых, мы использовали ключевое слово [Theorem] вместо [Example].
    Данная разница является лишь разницей в стиле. Ключевые слова
    This difference is purely a matter of style; the keywords
    [Example] и[Theorem] (а также несколько других, включая [Lemma],
    [Fact], и [Remark]) означают одно и тоже в Coq.

    Во вторых, мы добавили квантор [forall n:nat], так что наша теорема
    говорил обо _всех_ натуральных числах [n]. Для того чтобы доказать
    теоремы в такой форме, нам необходимо уметь рассуждать _предполагая_ 
    существование произвольного натурального числа [n]. Это достигается
    в доказательства использованием [intros n], которая переносит квантор
    из цели в _контекст_ текущих предположений. Эффективно, мы начинаем
    доказательство словамми "Предположим [n] есть некоторое произвольное
    число..."

    Ключевые слова [intros], [simpl], и [reflexivity] являются примерами
    _тактик_.  Тактика это команда которая используется между [Proof] и
    [Qed] для направления процесса проверки заявления, которое мы делаем.
    Мы увидем несколько новых тактик в данной главе и еще более в последующих.

    Другие похожие теоремы могут быть доказаны схожим способом. *)

Theorem plus_1_l : forall n:nat, 1 + n = S n.
Proof.
  intros n. reflexivity.  Qed.

Theorem mult_0_l : forall n:nat, 0 * n = 0.
Proof.
  intros n. reflexivity.  Qed.

(** Суффикс [_l] в именах теорем произносится как "слева." *)

(** Стоит проитись пошагово через данные доказательства и пронаблюдать
    как меняются контекст и цель. *)
(** Вы можете добавить вызовы [simpl] перед [reflexivity] для того
    чтобы увидеть какие упрощения производятся Coq на термах перед
    проверкой на равность.

    Хотя упрощение достаточно мощно чтобы доказать вполне общие факты,
    существует много утверждений, которые не могут быть разрешены одним
    лишь упрощением. Например, мы не можем доказать, что [0] является
    нейтральным элементом для [+] _справа_. *)

Theorem plus_n_O : forall n, n = n + 0.
Proof.
  intros n. simpl. (* Ничего не делает! *)

(** (Можете объяснить почему это происходит? Пройдитесь через
    оба доказательства в Coq и обратите внимание на цель и контекст.)

    Когда мы застряли посередине доказательства, мы можем использовать
    команду [Abort] для того чтобы оставитъ его. *)

Abort.

(** Следующая глава вводит _индукцию_, мощную технику которая позволит
    доказать данную цель. На данный момент, давайте взглянем на несколько
    других простых тактик. *)

(* ###################################################################### *)
(** * Доказательство Переписыванием *)

(** Следующая теорема несколько более интересна, чем уже увиденные: *)

Theorem plus_id_example : forall n m:nat,
  n = m ->
  n + n = m + m.

(** Вместо того чтобы делать универсальное заявление обо всех числах [n] и [m],
    она говорит о более специализированном свойстве, которое справедливо только
    если [n = m].  Символ стрелки произносится как "следует."

    Как и раньше, нам необходимо уметь рассуждать предполагая существование
    некоторых чисел [n] и [m]. Нам также необходимо предполагать гипотезу
    [n = m]. Тактика [intros] послужит для того чтобы переместить все три
    компонента из цели в контекст.

    Так как [n] и [m] произвольные числа, мы не можем просто использовать
    упрощение для доказательства теоремы. Вместо этого, мы доказываем ее 
    замечая, что предположив [n = m], можно заменить [n] на [m] в утверждении
    цели и получить равенство с одинаковым выражением с обеих сторон.
    Тактика что говорит Coq сделать такую замену называется [rewrite]. *)

Proof.
  (* перевести кванторы в контекст: *)
  intros n m.
  (* перенести гипотезу в контекст: *)
  intros H.
  (* переписать цель используя гипотезу: *)
  rewrite -> H.
  reflexivity.  Qed.

(** Первая строка доказательства переносит кванторы всеобщности
    для переменных [n] и [m] в контекст. Следующая переносит
    гипотезу [n = m] в контекст и задает ей имя [H]. Третья
    говорит Coq переписать текущую цель ([n + n = m + m]),
    заменяя левую часть из гипотезы равенства [H] ее правой частью.

    (Символ стрелки в [rewrite] не имеет ничего общего с импликацией:
    она говорит Coq применить переписывание с лева направо.
    Чтобы перписать справа на лево, можно использовать [rewrite <-].
    Попробуйте сделать эти изменения в предыдущем доказательства   
    и посмотрите на разницу, которую это производит.) *)

(** **** Упражнение: 1 звездочка (plus_id_exercise)  *)
(** Удалите "[Admitted.]" и запоните доказательство. *)

Theorem plus_id_exercise : forall n m o : nat,
  n = m -> m = o -> n + m = m + o.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** Команда [Admitted] говорит Coq что мы хотим пропустить попытку
    доказательства данной теоремы и просто принять ее как данное.
    Это может быть полезно для разработки длинных доказательств, так
    как мы можем формулировать вспомогательные леммы для предоставления
    нужных аргументов, использовать [Admitted] для принятия их временно
    на веру и продолжить работать над главным аргументом пока мы не 
    станем уверенны, что он имеет смысл; тогда можно вернуться назад
    и заполнить все пропущенные доказательства. Будьте осторожны, каждый
    раз вы используете [Admitted] (или [admit]) вы оставляете открытую дверь
    для полной чуши в мире прекрасного, точного и формально проверенного
    мира Coq! *)

(** Мы также можем использовать тактику [rewrite] с предыдуще доказанной теоремой
    вместо гипотезы из контекста. Если утверждение из предыдуще доказанной теоремы
    включает кванторы всеобщности, как в примере снизу, Coq пытается инстанционировать
    их значениями соответствующими текущей цели. *)   

Theorem mult_0_plus : forall n m : nat,
  (0 + n) * m = n * m.
Proof.
  intros n m.
  rewrite -> plus_O_n.
  reflexivity.  Qed.

(** **** Упражнение: 2 звездочки (mult_S_1)  *)
Theorem mult_S_1 : forall n m : nat,
  m = S n ->
  m * (1 + n) = m * m.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)


(* ###################################################################### *)
(** * Доказательство Разбором Случаев *)

(** Конечно не все может быть доказано простым вычислением и переписыванием.
    В основном, гипотетические неизвестные значения (произвольные числа,
    булевы, списки и т.д.) могут блокировать упрощение. Например, если мы
    пробуем доказать следующий факт используя тактику [simpl], как делали
    раньше, то мы застреваем. *)

Theorem plus_1_neq_0_firsttry : forall n : nat,
  beq_nat (n + 1) 0 = false.
Proof.
  intros n.
  simpl.  (* ничего не делает! *)
Abort.

(** Причина заключается в том, тчо определения как [beq_nat], так и [+] 
    начинаются с паттерн матчинга (сопоставление с образцом) на их первом 
    аргументе. Однако здесь первый аргумент к [+] неизвестное число [n] 
    и аргумент к [beq_nat] есть составное выражение [n + 1]. Ни то, ни
    другое не может быть упрощено.

    Чтобы продвинуться дальше, нам надо отдельно рассмотреть возможные формы [n].
    Если [n] есть [O], тогда мы посчитаем конечный результат [beq_nat (n + 1) 0] 
    и убедимся, что это действительно [false]. А если [n = S n'] для некоторого [n'],
    тогда мы не знаем какое конкретно число получится при вычислении [n + 1], но му можем
    посчитать, что оно по крайней мере будет начинаться хотябы с одного [S], и этого
    уже достаточно, чтобы посчитать, что [beq_nat (n + 1) 0] действительно [false].

    Тактика которая говорит Coq рассмотреть отдельно случаи [n = O] и [n = S n']
    называется [destruct]. *)

Theorem plus_1_neq_0 : forall n : nat,
  beq_nat (n + 1) 0 = false.
Proof.
  intros n. destruct n as [| n'].
  - reflexivity.
  - reflexivity.   Qed.

(** [destruct] генерирует _две_ подцели, которые надо доказать отдельно,
    для того, чтобы Coq принял теорему. Аннотация "[as [| n']]" называетсяis called an
    _интро паттерном_. Она указывает Coq каке имена переменных надо ввести в каждую
    из подцелей. В целом, то что записывается между квадратными скобками есть
    _список списков_ имен, разделенных [|].  В данном случае, первый компонент пуст,
    так как конструктор [O] не имеет никаких аргументов. Второй компонент задает одно имя
    потому что конструктор [S] унарен.

    Знаки [-] на второй и третьей строках называются _маркеры_,
    и они маркируют части доказательств, которыч относятся как
    каждой сгенерированной подцели. Скрипт доказательства, что
    идет после маркера является доказательством подцели. В данном
    примере каждая подецель была легко доказана однократным применением
    [reflexivity], которая сама по себе делает некоторе упрощение -- т.е.,
    во первых упрощает [beq_nat (S n' + 1) 0] до [false] переписыванием
    [(S n' + 1)] в [S (n' + 1)], затем раскрытием [beq_nat], а после
    упрощает [match].

    Маркирование случаев является полностью опциональным. Если маркеры
    отсутствуют, Coq просто требует последовательно и по очереди доказать каждую подцель.
    Тем не менее, использовать маркеры хорошая идея. Хотя бы потому,
    что они делают структуру доказательства более понятной и более читабельной.
    Также маркеры инструктируют Coq убедиться, что подцель закончена прежде
    чем верифицировать следующую, предохраняя от смешивания доказательств
    для разных подцелей. Это становится особенно важным в случае больших
    разработок, где хрупкие доказательства приводят к длинным сессиям
    дебага.

    Нет строгих или быстрых правил того как доказательства должны
    быть отформатированы в  Coq -- в частности, когда должен быть переход
    на новую строку и какие отступы должны иметь секции доказательств
    для индикации их вложенной структуры.  Тем не менее, если места где
    сгенерированы многочисленные подцели отмечены маркерами явно вначале
    линий, то доказательство будет читаемым практически независимо от
    выбора других аспектов форматированния.

    Это также хорошее место чтобы выделить другой несколько очевидный
    совет о длинах строк. Начинающие пользователи Coq иногда стремятся
    к крайностям, либо записывают каждую тактику на одной строке, либо
    пробуют умещать все доказательство в одной строке. Хороший стиль
    находится где то посередине. Разумным подходом было бы ограничивать 
    себя 80-символьными строками.

    Тактика [destruct] может быть использована с любой индуктивно заданной
    структурой данных. Например, мы используем ее в следующем доказательстве
    того, что отрицание инволютивно -- т.е. , что отрицание является обратной
    операцией для себя. *)

Theorem negb_involutive : forall b : bool,
  negb (negb b) = b.
Proof.
  intros b. destruct b.
  - reflexivity.
  - reflexivity.  Qed.

(** Заметьте, что [destruct] здесь не имеет [as], так как
    ни один из подслучаев [destruct] требует связывания с какой либо переменной,
    таким образом нет никакой необходимости задавать какие либо имена.
    (Мы также могли бы записать [as [|]], или [as []].)  На самом деле, мы
    можем опустить [as] из _любого_ [destruct] и Coq сам заполнит имена переменных
    автоматически. Это обычно считается плохим стилем, так как Coq
    часто задает сбивающие с толку имена переменных, когда оставлен
    на себя.

    Иногда полезно вызвать [destruct] внутри подцели, генерируя еще больше
    требований для доказательств. В этом случае, мы используем другой вид
    маркеров для выделения целей разных "уровней".
    Например: *)

Theorem andb_commutative : forall b c, andb b c = andb c b.
Proof.
  intros b c. destruct b.
  - destruct c.
    + reflexivity.
    + reflexivity.
  - destruct c.
    + reflexivity.
    + reflexivity.
Qed.

(** Каждая пара вызовов [reflexivity] соответствует подцелям, которые
    мы сгенерировали после запуска [destruct c] строки сверху.
    Кроме [-] и [+], Coq доказательства могут использовать [*] (звездочку) 
    в качестве третьего маркера. Если мы когда нибудь встретим доказательство
    которое генерирует больше трех уровней подцелей, мы можем также
    включать индивидуальные подцели в фигурные скобки ([{ ... }]): *)

Theorem andb_commutative' : forall b c, andb b c = andb c b.
Proof.
  intros b c. destruct b.
  { destruct c.
    { reflexivity. }
    { reflexivity. } }
  { destruct c.
    { reflexivity. }
    { reflexivity. } }
Qed.

(** Так как фигурные скобки отмечают как начало, так и конец доказательства,
    они могут быть использованы для множественных уровней подцелей,
    как показывает данный пример. Более того, фигурные скобки позволяют
    нам повторно использовать маркеры на многих уровнях доказательства: *)

Theorem andb3_exchange :
  forall b c d, andb (andb b c) d = andb (andb b d) c.
Proof.
  intros b c d. destruct b.
  - destruct c.
    { destruct d.
      - reflexivity.
      - reflexivity. }
    { destruct d.
      - reflexivity.
      - reflexivity. }
  - destruct c.
    { destruct d.
      - reflexivity.
      - reflexivity. }
    { destruct d.
      - reflexivity.
      - reflexivity. }
Qed.

(** Перед тем как завершить главу, упомянем еще одно удобное обозначение.
    Как вы уже заметили, многие доказательства делают разбор случаев
    на переменной сразу после  ее введения:

       intros x y. destruct y as [|y].

    Данный шаблон настолько часто встречается, что Coq предоставляет сокращение
    для него: мы можем делать разбор случаев на переменной, когда вводим ее
    используя паттерн интро вместо имени переменной. Например, приведем
    более короткое доказательство теоремы [plus_1_neq_0]. *)

Theorem plus_1_neq_0' : forall n : nat,
  beq_nat (n + 1) 0 = false.
Proof.
  intros [|n].
  - reflexivity.
  - reflexivity.  Qed.

(** Если нет никаких аргументов для имени, то можно записать просто [[]]. *)

Theorem andb_commutative'' :
  forall b c, andb b c = andb c b.
Proof.
  intros [] [].
  - reflexivity.
  - reflexivity.
  - reflexivity.
  - reflexivity.
Qed.

(** **** Упражнение: 2 звездочки (andb_true_elim2)  *)
(** Докажите следующее утверждение, маркируя случаи (и подслучаи) 
    когда используете [destruct]. *)

Theorem andb_true_elim2 : forall b c : bool,
  andb b c = true -> c = true.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** **** Упражнение: 1 звездочка (zero_nbeq_plus_1)  *)
Theorem zero_nbeq_plus_1 : forall n : nat,
  beq_nat 0 (n + 1) = false.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(* ###################################################################### *)
(** ** Больше о Нотации (дополнительный материал) *)

(** (В целом, секции отмеченные как дополнительный материал не нужны
    для того чтобы следовать материалу книги в дальнейшем, за исключением
    возможно других секций дополнительного материала. При первом чтении
    вы можете пройтись по нему для того чтобы знать что там содержиться
    и вернуться если по каким то причинам эта информация вам нужна.)

    Вспомните определения нотаций для инфиксных операций plus и times: *)

Notation "x + y" := (plus x y)
                       (at level 50, left associativity)
                       : nat_scope.
Notation "x * y" := (mult x y)
                       (at level 40, left associativity)
                       : nat_scope.

(** Для каждого символа нотации в Coq, мы можем задать _уровень приоритета_ 
    и его _ассоциативность_.  Уровень приоритета [n] определяется записью
    вида [at level n]; она помогает Coq работать с составными выражениями.
    Настройка ассоциативности помогает разобраться с выражениями имеющими
    несколько появлений одного и того же символа. Например, параметры
    определенные сверху для плюса [+] и [*] говоря что выражение [1+2*3*4] есть
    сокращение [(1+((2*3)*4))]. Coq использует уровни приоритета от 0 до 100, 
    и _left_, _right_, или _no_ для ассоциативности.  Мы увидем больше примеров
    в дальнейшем, например в главе [Lists].

    Каждый символ нотации также ассоциирован с _областью нотации_.
    Coq пытается угадать какая область имеется ввиду исходя из контекста,
    так что когда он видит [S(O*O)] он угадывает [nat_scope], но когда он видит
    декартово произведение (кортеж) [bool*bool] он угадывает
    [type_scope].  Иногда, необходимо помочь ему в этом используя
    нотацию процента, записываяэ [(x*y)%nat], и бывает что то что 
    выводится Coq на экран использует [%nat] для индикации области нотации.

    Области нотации также могут относится к цифровой нотации ([3], [4], [5],
    и.т.д.), так что иногда вы можете увидеть [0%nat], что означает [O] 
    ( натуральное число [0] которое мы используем в данной главе), или [0%Z],
    означающее целочисленный нуль (Integer zero) (который определен в другой
    части стандартной библиотеки). *)

(* ###################################################################### *)
(** ** Fixpointы и Структурная Реккурсия (Дополнительный материал) *)

(** Вот копия определения суммы: *)

Fixpoint plus' (n : nat) (m : nat) : nat :=
  match n with
  | O => m
  | S n' => S (plus' n' m)
  end.

(** Когда Coq проверяет данное определение, он замечает, что [plus']
    "уменьшается на первом аргументе." Это означает, что мы делаем
    _структурную реккурсию_ на аргументе [n] -- т.е., мы делаем
    реккурсивные вызовы только на строго меньших значениях
    [n].  Из этого следует, что вызовы к [plus'] в итоге закончаться.
    Coq ребует чтобы какой либо аргумент _каждого_ [Fixpoint]
    определения был "уменьшающийся."

    Данное требование является дунфаментальным свойством дизайна Coq.
    В частности, оно гарантирует, что каждая функция, которая может быть
    определена в Coq будет завершаться на всех своих входах. Тем не менее,
    так как "анализ уменьшений" Coq не очень сложный, иногда приходится 
    записывать функции слегка неестественными способами. *)

(** **** Упражнение: 2 звездочки, дополнительное (уменьшение)  *)
(** Чтобы понять это яснее, найдите способ записать осмысленное
    определение [Fixpoint] (простой фунции на числах, например) которая
    _завершается_ на всех входах, но Coq не примет ее из за данного
    ограничения. *)

(* Заполните здесь *)
(** [] *)

(* ###################################################################### *)
(** * Дополнительные Упражнения *)

(** **** Уюражнение: 2 звездочки (boolean_functions)  *)
(** Используйте тактики что бы уже узнали для доказательства следующей
    теоремы о булевых функциях. *)

Theorem identity_fn_applied_twice :
  forall (f : bool -> bool),
  (forall (x : bool), f x = x) ->
  forall (b : bool), f (f b) = b.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

(** Теперь сформулируйте и докажите теорему [negation_fn_applied_twice] 
    аналогичную предыдущей, но со второй гипотезой говорящей, что
    функция [f] имеет свойство [f x = negb x].*)

(* ЗАПОЛНИТЕ ЗДЕСЬ *)
(** [] *)

(** **** Упражнение: 2 звездочки (andb_eq_orb)  *)
(** Докажите следующую теорему.  (Вам может сначало захотеться
    доказать сначало вспомагательную лемму или две. Как альтернативу,
    помните, что вам нет необходимости вводит все гипотезы одновременно.) *)

Theorem andb_eq_orb :
  forall (b c : bool),
  (andb b c = orb b c) ->
  b = c.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** **** Упражнение: 3 звездочки (binary)  *)
(** Рассмотрите другое, более эффективное представление натуральных чисел
    использующее бинарную, а не унарную систему. Таким образом, вместо
    того чтобы говорить, что каждаое натуральное число есть либо нулъ,
    либо следущее по отношению к некоторому натуральному числу, мы можем 
    сказать, что каждое бинарное число есть либо

      - нуль,
      - дважды бинарное число, или
      - на одно больше чем дважды бинарное число.

    (a) Во первых, запишите индуктивное определение типа [bin]
        соответствующее данному описанию бинарных чисел.

    (Подсказка: вспомните определение [nat] из класса,

         Inductive nat : Type :=
           | O : nat
           | S : nat -> nat.

    ничего не говорит о том что [O] и [S] "значат."  Оно только говорит
    "[O] принадлежит множеству [nat], и если [n] принадлежит множеству
    то и [S n]. такюе"  Интерпретация [O] как нуля и [S] как следующего/плюс
    один, приходит от способа _использования_ значений [nat], от написания
    функций которые что то делают с ними, доказательства теорем о них,
    и так далее. Ваше определение [bin] должно быть аналогично простым.
    Функции, которые вы запишите дальше придадут ему математический смысл.)

    (b) Далее, запишите функцию инкремента [incr] для бинарных чисел,
        и функцию [bin_to_nat] для конвертирования бинарных чисел в унарные.

    (c) Запишите пять юнит тестов [test_bin_incr1], [test_bin_incr2], и т.д..
        для ваших функций инкремента и перевода из бинарного в унарный формат.
        Заметьте, что инкрементируя бинарное число и затем конвертируя его
        в унарное должно давать тот же результат, как если конвертировать в
        унарное, а затем инкрементировать.
*)

(* ЗАПОЛНИТЕ ЗДЕСЬ *)
(** [] *)

(** $Date: 2016-05-26 16:17:19 -0400 (Thu, 26 May 2016) $ *)

