(** * Индукция: Доказательство по Индукции *)

(** Во первых, импортируем все наши определения из предыдущей главы. *)

Require Export Basics.

(** Для того чтобы [Require Export] заработало, нам сначало необходимо
    использовать [coqc] для компиляции [Basics.v] в [Basics.vo]. Это 
    похоже на то как делается .class файл из .java файла, или .o файл из .c
    файла. Есть два способа это сделать:

     - В CoqIDE:

         Открыть [Basics.v].  В меню "Compile", кликнуть на "Compile
         Buffer".

     - Из командной строки:

         Запустить [coqc Basics.v]

    *)

(* ###################################################################### *)
(** * Доказательство по индукции *)

(** В прошлой главе мы доказали что [0] есть нейтральный элемент 
    слева для [+], используя простой аргумент основанный на упрощении.
    Факт того, что он также является нейтральным элементом _справа_... *)

Theorem plus_n_O_firsttry : forall n:nat,
  n = n + 0.

(** ... не может быть доказан таким же простым способом. Простое
  применение [reflexivity] не срабатывает, так как [n] в [n + 0] есть
  произвольное неизвестное число, поэтому [match] в определении [+] не может
  быть упрощен.  *)

Proof.
  intros n.
  simpl. (* Ничего не происходит! *)
Abort.

(** Рассужение с перебором случаев и использованием [destruct n] также не
   продвигает нас далеко: ветвь анализа случаев, где мы предполагаем [n = 0]
   доказывается хорошо, но ветвь [n = S n'] для некоторого [n'] останавливает
   нас аналогично предыдущей попытке.  Мы можем использовать [destruct n']
   для продвижения на еще один шаг, но, так как [n] произвольно большое, то
   делая таким образом никогда не закончим. *)

Theorem plus_n_O_secondtry : forall n:nat,
  n = n + 0.
Proof.
  intros n. destruct n as [| n'].
  - (* n = 0 *)
    reflexivity. (* пока хорошо... *)
  - (* n = S n' *)
    simpl.       (* ...но здесь мы застряли опять *)
Abort.

(** Для доказательства интересных фактов о числах, списках и 
    других индуктивно определенных множествахм нам нужен более
    мощный принцип вывода: _индукция_.

    Вспомните (из школы или курса дискретной математики) принцип
    индукции на натуральных числах: Если [P(n)] есть некоторое
    утверждение (пропозиция) включающая натуральное число [n] и
    мы хотим показать, что [P] справедливо для _всех_ чисел [n], 
    мы можем рассуждать следующим образом:
         - показать справедливость [P(O)];
         - показать что, для любого [n'], если [P(n')] справесливо, 
           то также справедливо [P(S n')];
         - заключить что [P(n)] справедливо для всех [n].

    В Coq, шаги остаются теми же, но в противоположном порядке:
    мы начинаем с цели [P(n)] для всех [n] и разбиваем 
    (используя тактику [induction]) на две подцели:
    во первых показываем [P(O)] а затем показываем [P(n') -> P(S
    n')].  Вот как это работает для нашей теоремы: *)


Theorem plus_n_O : forall n:nat, n = n + 0.
Proof.
  intros n. induction n as [| n' IHn'].
  - (* n = 0 *)    reflexivity.
  - (* n = S n' *) simpl. rewrite <- IHn'. reflexivity.  Qed.

(** Как и [destruct], тактика [induction] принимает условие [as...]
    для определения имен переменных, которые надо ввести в подцели.
    В первой ветке, [n] заменяется на [0] и целью становится
    [0 + 0 = 0], что доказывается упрощением. Во второй, [n] заменяется
    [S n'] и утверждение [n' + 0 = n'] добавляется в контекст (под именем [IHn'],
    т.е., Индуктивная Гипотеза для [n'] -- заметьте, что это имя
    явным образом выбрано [as...] условием вызова [induction]
    вместо предоставления выбора Coq). Целью в данном случае становится
    [(S n') + 0 = S n'], что упрощается до [S (n' + 0)
    = S n'], которая в свою очередь следует из [IHn']. *)

Theorem minus_diag : forall n,
  minus n n = 0.
Proof.
  (* СДЕЛАНО В КЛАССЕS *)
  intros n. induction n as [| n' IHn'].
  - (* n = 0 *)
    simpl. reflexivity.
  - (* n = S n' *)
    simpl. rewrite -> IHn'. reflexivity.  Qed.

(** (Использование тактики [intros] в данных доказательствах на самом
     излишне. Когда применено к цели содежащей квантор всеобщности,
     тактика [induction] автоматически переместит эти переменные 
     в контекст по мере необходимости.) *)

(** **** Упражнение: 2 звездочки, рекомендовано (basic_induction)  *)
(** Докажите следующее используя индукцию. Вам могут понадобиться
    предыдуще доказанные результаты. *)

Theorem mult_0_r : forall n:nat,
  n * 0 = 0.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Theorem plus_n_Sm : forall n m : nat, 
  S (n + m) = n + (S m).
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Theorem plus_comm : forall n m : nat,
  n + m = m + n.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Theorem plus_assoc : forall n m p : nat,
  n + (m + p) = (n + m) + p.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** **** Упражнение: 2 звездочки (double_plus)  *)
(** Рассмотрите следующую функцию, которая удваивает свой аргумент: *)

Fixpoint double (n:nat) :=
  match n with
  | O => O
  | S n' => S (S (double n'))
  end.

(** Используя индукцию докажите следующий простой факт о [double]: *)

Lemma double_plus : forall n, double n = n + n .
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** **** Упражнение: 2 звездочки, дополнительное (evenb_S)  *)
(** Один неудобный аспект нашего определения [evenb n] состоит в том, что
    оно требует реккурсивного вызова на [n - 2]. Это делает доказательства
    связанные с [evenb n] труднее, когда используется индукция по [n], так как
    нам может понадобиться индуктивная гипотеза о [n - 2]. Следующая лемма
    предоставляет более удобную характеристику [evenb (S n)]: *)

Theorem evenb_S : forall n : nat,
  evenb (S n) = negb (evenb n).
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** **** Упражнение: 1 звездочка (destruct_induction)  *)
(** Коротко изложите разницу между тактиками [destruct] 
    и [induction].

(* ЗАПОЛНИТЕ ЗДЕСЬ *)
*)
(** [] *)

(* ###################################################################### *)
(** * Доказательства в Доказательствах *)

(** В Coq, как и в обычной математике, большие доказательства часто
    разбиваются на последовательность теорем, с последующими теоремами
    ссылающимися на предыдущие теоремы. Но иногда доказательства требует
    некоторый факт который слишком тривиалем и мал, чтобы представлять
    интерес в виде формулировки в виде отдельной теоремы. В таких случая
    было бы удобно иметь возможность просто сформулировать и доказать
    необходимую "подтеорему" прямо на месте ее использования. Тактика
    [assert] позволяет это сделать. Например, наше ранее доказательство
    теоремы [mult_0_plus] обращалось к предыдущей теореме [plus_O_n].
    Вместо этого мы могли бы использовать [assert] для формулировки
    и доказательства [plus_O_n] внутри: *)

Theorem mult_0_plus' : forall n m : nat,
  (0 + n) * m = n * m.
Proof.
  intros n m.
  assert (H: 0 + n = n). { reflexivity. }
  rewrite -> H.
  reflexivity.  Qed.

(** Тактика [assert] вводит две подцели. Первая подцель это само нужное
    нам утверждение, используя [H:] мы задаем ему имя [H].  (Мы также
    можем задать имя утверждения с помощью [as] как мы это делали
    раньше в случае [destruct] и [induction], т.е., [assert (0 + n
    = n) as H].)  Заметьте, как мы выделяем доказательство утверждения
    фигурными скобками [{ ... }], как для читаемости, так и для того,
    чтобы в интерактивной сессии Coq легче видеть когда мы закончили
    под докозательство. Вторая цель такая же как и предыдущая в момент
    до использования [assert] за исключением того, что теперь у нас
    в контексте утверждение [H] о том что [0 + n = n].  Таким образомо,
    [assert] генерирует одну подцель, в которой мы должны  доказать
    нужный нам факт и вторую подцель где мы можем использовать
    данный факт для дальнейшего прогресса в том что мы с самого
    начала пытались доказать. *)

(** Тактика [assert] пригождается во многих ситуациях. Например, предположим
    что мы хотим доказать что [(n + m) + (p + q) = (m +
    n) + (p + q)]. Единственная разница между обоими частями [=] состоит
    в том, что аргументы [m] и [n] в первом внутреннем [+] переставлены
    местами, и кажется что нам может помочь коммутативность сложения ([plus_comm])
    для переписывания одной части в другую. Тем не менне, тактика [rewrite]
    немного глупа в том _где_ она применяет переписывание. У нас есть
    три использование [+], и оказывается, что [rewrite -> plus_comm] воздействует
    только на _внешнее_ сложение... *)

Theorem plus_rearrange_firsttry : forall n m p q : nat,
  (n + m) + (p + q) = (m + n) + (p + q).
Proof.
  intros n m p q.
  (* Нам просто нужно переставить (n + m) на (m + n)...
     кажется plus_comm должно это сделать! *)
  rewrite -> plus_comm.
  (* Не работает...Coq переписал неправильный плюс! *)
		     Abort.

(** Чтобы [plus_comm] был применен в точке, которая нам нужна, мы можем ввести локальную
    лемму, утверждающую [n + m = m + n] (для конкретного [m] и [n] с которыми мы работаем), 
    доказать данную лемму используя [plus_comm], а затем применить ее для требуемого
    переписывания. *)

Theorem plus_rearrange : forall n m p q : nat,
  (n + m) + (p + q) = (m + n) + (p + q).
Proof.
  intros n m p q.
  assert (H: n + m = m + n).
  { rewrite -> plus_comm. reflexivity. }
  rewrite -> H. reflexivity.  Qed.

(* ###################################################################### *)
(** * Больше Упражнений *)

(** **** Упражнение: 3 звездочки, рекомендованное (mult_comm)  *)
(** Используйте [assert] как помощь в доказательстве теоремы. Нет необходимости
   использовать индукцию в [plus_swap]. *)

Theorem plus_swap : forall n m p : nat,
  n + (m + p) = m + (n + p).
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

(** Теперь докажите коммутативность умножения.  (Вам наверное понадобится
    определить и доказать отдельную вспомогательную лемму для использования
    в основном доказательства. Вы можете найти [plus_swap] полезной.) *)

Theorem mult_comm : forall m n : nat,
  m * n = n * m.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** **** Упражнение: 3 звездочки, дополнительное (больше упражнений)  *)
(** Возьмите лист бумаги. Для каждой из следующих теорем, во первых
    _подумайте_ о (a) может ли она быть доказана с использованием лишь
    упрощением и переписыванием, (b) требует ли она также анализа случаев
    ([destruct]), или (c) также потребуется индукция. Запишите ваше предсказание.
    Затем заполните доказательство. (Нет необходимости приносить или показывать
    ваш лист с предсказаниями. Это исключительно для тренировки мысли!) *)

Theorem leb_refl : forall n:nat,
  true = leb n n.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Theorem zero_nbeq_S : forall n:nat,
  beq_nat 0 (S n) = false.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Theorem andb_false_r : forall b : bool,
  andb b false = false.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Theorem plus_ble_compat_l : forall n m p : nat,
  leb n m = true -> leb (p + n) (p + m) = true.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Theorem S_nbeq_0 : forall n:nat,
  beq_nat (S n) 0 = false.
Proof.
  (* ЗАПОЛОЛНИТЕ ЗДЕСЬ *) Admitted.

Theorem mult_1_l : forall n:nat, 1 * n = n.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Theorem all3_spec : forall b c : bool,
    orb
      (andb b c)
      (orb (negb b)
               (negb c))
  = true.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Theorem mult_plus_distr_r : forall n m p : nat,
  (n + m) * p = (n * p) + (m * p).
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.

Theorem mult_assoc : forall n m p : nat,
  n * (m * p) = (n * m) * p.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** **** Упражнение: 2 звездочки, дополнительное (beq_nat_refl)  *)
(** Докажите следующую теорему.  (Ставить [true] в левую часть
    равенства может показаться странным, но это так как данная теорема
    определена в стандартной библиотеке Coq, так что мы просто следуем
    их выбору. Переписывание работает одинакого хорошо в обоих направлениях,
    так что мы не будем иметь проблем от нашего способа формулировки
    данной теоремы.) *)

Theorem beq_nat_refl : forall n : nat,
  true = beq_nat n n.
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** **** Упражнение: 2 звездочки, дополнительное (plus_swap')  *)
(** Тактика [replace] позволяет указать конкретный подтерм для переписывания
   и на что именно он должен быть переписан: [replace (t) with (u)]
   заменяет (все копии) выражения [t] в цели на выражения
   [u], и генерирует [t = u] в качестве дополнительной подцели. Это часто полезно
   когда просто [rewrite] воздействует на неправильную часть цели.

   Используйте тактику [replace] чтобы доказать [plus_swap'], аналогичную
   [plus_swap] но без использования [assert (n + m = m + n)]. *)

Theorem plus_swap' : forall n m p : nat,
  n + (m + p) = m + (n + p).
Proof.
  (* ЗАПОЛНИТЕ ЗДЕСЬ *) Admitted.
(** [] *)

(** **** Упражнение: 3 звездочки, рекомендовано (binary_commute)  *)
(** Вспомните функции [incr] и [bin_to_nat], которые вы написали для
    упражнения [binary] главы [Basics]. Докажите, что следующая
    диаграмма коммутирует:

               bin --------- incr -------> bin
                |                           |
            bin_to_nat                  bin_to_nat
                |                           |
                v                           v
               nat ---------- S ---------> nat

    А именно, инкрементируя бинарное число и конвертируя его в унарное
    производит тот же результат, что и конвертация в натуральное число с
    последующим инкрементированием. Назовите свою теорему [bin_to_nat_pres_incr] 
    ("pres" от "preserves").

    Прежде чем начать работать над упражнением, скопируйте определения
    из вашего решение упражнения [binary] так чтобы данный файл оценивался
    самостоятельно. Если вы находите более удобным поменять оригинальные
    определения для упрощения доказательства, то можете это сделать! *)

(* ЗАПОЛНИТЕ ЗДЕСЬ *)
(** [] *)

(** **** Упражнение: 5 звездочек, продвинутое (binary_inverse)  *)
(** Данное упражнение является продолжением предыдущего упражнения о
    бинарных числах. Вам понадобятся ваши определения и теоремы оттуда
    для завершения этого упражнения.

    (a) Во первых, напишите функцию конвертирующую натуральные числа
        в бинарные числа. Затем докажите что начиная с произвольного
        натурального числа, конвертирую его в бинарное, а затем обратно
        получается то же натуральное число, с которого мы начали.

    (b) Вы можете естественно подумать, что можно доказать аналогичный
        факт в обратном направлении: начав с бинарного числа, сконвертиров
        его в натуральное, а затем обратно в бинарное, мы получим
        то же число с которого начали. Там не менее, это не так!
        Объясните в чем здесь состоит проблема.

    (c) Определите функцию "прямой" нормализации -- т.е., функцию
        [normalize] из бинарных чисел в бинарные числа, так чтобы для
        любого бинарного числа b, конвертируя его в натуральное, а затем обратно
        получилось бы [(normalize b)].  Докажите это.  (Предупреждение: данная
        часть сложна!)

    Опять же, совободно меняйте свои предыдущие определения, если это вам 
    здесь поможет. *)

(* ЗАПОЛНИТЕ ЗДЕСЬ *)
(** [] *)

(* ###################################################################### *)
(** * Формальные и Неформальные Доказательства (Дополнительный Материал) *)

(** "_Неформальные доказательства есть алгоритмы; формальные доказательства есть код_." *)

(** Вопрос что же состовляет доказательство математического утверждения
    волновал философов тысячелетия. Готовое и грубое определение было
    бы таким: доказательство математического утверждения [P] это 
    записаный (или сказанный) текст, который приводит читателя или
    слушателя к твердому убеждению того что [P] справедливо. Таким образом,
    доказательство это акт коммуникации.

    Акты коммуникации могут включать в себя разные типы "читателей".
    С одной стороны, "читателем" могут быть программы вроде Coq, и в этом
    случае "вера" основывается на том что [P] может быть механистически
    выведено из некоторог множества формальных логических правил, и 
    доказательство эт рецепт, который помогает программе проверить
    заданный факт. Такие рецепты и есть _формальные доказательства_.

    Альтернативно, читателем может быть человек, и в этом случае
    доказательство будет записано на некотором естественном языке,
    и таким образом будет _неформальным_. Здесь, критерии успеха
    определены менее ясно. "Валидное" доказательством является то,
    которое позволяет убедить читателя поверить в [P]. Однако, тоже
    самое доказательство может быть прочитано разными читателями,
    некоторые из которых могут быть убеждены данным конкретным
    способом выразить агумент, в то время как другие могут и не быть.
    Отдельные читатели могут быть педантичны, неопытны или просто
    тугодумы. Единственный способ убедить таких это предоставить
    все мучительно детально. Другие читатели, более знакомые с
    конкретной областью могут найти такой обилие деталей неприемлемым,
    так как теряется общая суть.  Все что они хотят, это услышать
    главные идеи, так как для них легче заполнить детали самим, чем
    пробираться через из запись. Итого, не существует универсального
    стандарта, так как нет одного простого пути, которым неформальное
    доказательство гарантировало бы убедить любого возможного читателя.

    На практике, тем не менее, математики разработали богатый набор
    конвенций и идиом для описания сложных математических объектов,
    которые -- по крайней мере в рамках конкретных сообществ -- делают
    коммуникацию вполне надежной. Конвенции данные конвенции такой
    стилизованой формы коммуникации предоставляют вполне ясный
    стандарт для разделения хороших и плохих доказательств.

    Так как мы используем Coq в данном курсе, мы будем много работать
    с формальными доказательствами. Но это не означает, что мы можем
    полностью забыть о неформальных!  Формальные доказательства полезны
    многими способами, но они _не_ очень эффективны для коммуникации идей
    между людьми. *)

(** Например, приведем доказательство того, что суммирование аддитивно: *)

Theorem plus_assoc' : forall n m p : nat,
  n + (m + p) = (n + m) + p.
Proof. intros n m p. induction n as [| n' IHn']. reflexivity.
  simpl. rewrite -> IHn'. reflexivity.  Qed.

(** Coq вполне доволен этим. Для человека, тем не менее, достаточно
    трудно его понять. Мы можем использовать комментарии и маркеры
    чтобы показать структуру более ясно... *)

Theorem plus_assoc'' : forall n m p : nat,
  n + (m + p) = (n + m) + p.
Proof.
  intros n m p. induction n as [| n' IHn'].
  - (* n = 0 *)
    reflexivity.
  - (* n = S n' *)
    simpl. rewrite -> IHn'. reflexivity.   Qed.

(** ... и если вы привычны к Coq то сможете пройти через все тактики
    в своем воображении и представить сосотяния текущих цели и контекста
    в каждой точке. Хотя если доказательство станет немного более 
    сложным, то такое упражнение будет практически невозможным.

    Математик (педантичный) мог бы записать ээто доказательство примерно так: *)

(** - _Theorem_: For any [n], [m] and [p],

      n + (m + p) = (n + m) + p.

    _Proof_: Индукцией по [n].

    - Во первых, предположим [n = 0].  Мы должны показать

        0 + (m + p) = (0 + m) + p.

      Это следует напрямую из определения [+].

    - Далее, предположив [n = S n'], где

        n' + (m + p) = (n' + m) + p.

      Покажем

        (S n') + (m + p) = ((S n') + m) + p.

      По определению [+], это следует из

        S (n' + (m + p)) = S ((n' + m) + p),

      которое напрямую следует из гипотезы индукции.  _Qed_. *)


(** Общая форма доказательства в целом таже самая, и конечно же 
    это не случайность: Coq был задуман так, чтобы тактика
    [induction] генерировала бы теже подцели, в том же порядке,
    что математик бы написал сам. Однако есть существенная разница
    в степени детализации: формальное доказательство намного более
    явно выписанно в отдельных моментах (например, использование [reflexivity])
    но более неявное в других (в частности, "состояние доказательства"
    в каждый момент в доказательстве Coq задано полностью неявно,
    тогда как в неформальном доказательстве мы часто напоминаем читателю
    что на данный момент у нас есть). *)

(** **** Упражнение: 2 звездочки, продвинутое, рекомендованное (plus_comm_informal)  *)
(** Переведите ваше доказательство для [plus_comm] в неформальное доказательство:

    Теорема: Суммирование коммутативно.

    Доказательство: (* ЗАПОЛНИТЕ ЗДЕСЬ *)
*)
(** [] *)

(** **** Упражнение: 2 звездочки, дополнительное (beq_nat_refl_informal)  *)
(** Запишите неформальное доказательство следующей теоремы, используя неформально
    доказательство [plus_assoc] в качестве модели. Не надо просто перефразировать
    названия тактик Coq на русском!

    Теорема: [true = beq_nat n n] для любого [n].

    Доказательство: (* ЗАПОЛНИТЕ ЗДЕСЬ *)
[] *)

(** $Date: 2016-05-26 16:17:19 -0400 (Thu, 26 May 2016) $ *)
